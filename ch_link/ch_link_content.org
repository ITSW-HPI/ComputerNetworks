\label{ch:link}

\begin{frame}[title={bg=Hauptgebaeude_Tag}]
 \maketitle 
\end{frame}

#+latex_header: \usepackage{ifthen}
#+latex_header: \usetikzlibrary{decorations.pathreplacing,decorations.pathmorphing,calc}

#+BEGIN_EXPORT latex

\newcommand{\pplusa}[6]{%
  % #1: offset, #2: fill color #3: packet length #4: ACK length, #5 label
  % #6: X to loose the ACK 
  
  \coordinate (pStartSend_#5) at ($(a) + (0,-0.5)-(0,#1)$); 
  \coordinate (pEndSend_#5) at  ($  (pStartSend_#5) + (0,-#3) $ ); 
  \coordinate (pStartReceive_#5) at ($ (pStartSend_#5) + (3.5,-2) $); 
  \coordinate (pEndReceive_#5) at ($  (pStartReceive_#5) + (0,-#3) $ ); 
  \coordinate (aStartSend_#5) at ($(b) +  (0,-0.5)-(0,#1)-(0,2)-(0,#3)  $); 
  \coordinate (aEndSend_#5) at ($ (aStartSend_#5)  + (0,-#4) $); 
  \coordinate (aStartReceive_#5) at ($ (aStartSend_#5) + (-3.5,-2)  $); 
  \coordinate (aEndReceive_#5) at ($ (aStartReceive_#5) + (0,-#4)  $);   

  % Packets: 
  \ifthenelse{\equal{#6}{X}}
  {
    % packet gets lost
    \coordinate (pStartLoss_#5) at ($ (pStartSend_#5) + (1.75,-1)  $); 
    \coordinate (pEndLoss_#5) at ($ (pStartLoss_#5) + (0,-#3)  $);

    \draw [fill=#2, semitransparent] (pStartSend_#5) --
    (pStartLoss_#5) decorate [decoration=zigzag] {-- (pEndLoss_#5)}
    -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5 lost!}; 
    
  }
  {
    % packet normally delivered
  \draw [fill=#2, semitransparent] (pStartSend_#5) -- (pStartReceive_#5) -- (pEndReceive_#5) -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5}; 
  \draw [->] (a) ++ (pStartSend_#5) -- (pStartReceive_#5); 
  \draw [->] (a) ++ (pEndSend_#5) -- (pEndReceive_#5); 

  % ACK:
    %ACK normally sent: 
  \draw [fill=#2, semitransparent] (aStartSend_#5) -- (aStartReceive_#5) -- (aEndReceive_#5) -- (aEndSend_#5); 


  \draw [->] (aStartSend_#5) -- (aStartReceive_#5); 
  \draw [->] (aEndSend_#5) -- (aEndReceive_#5); 
}
}

#+END_EXPORT 



**** The story so far  

- Clarified basic options how to structure, design a network
  - Switching, multiplexing, layers, \dots
- Details of data transported via signals
- Inherent limitations:
  - Physical transport cannot avoid bit errors
  - It is just a string of bits
  - It ``receives'' bits even when none were sent 




**** Plans for this chapter 

- Understand the main service provided by the link layer
  - Communication between two directly connected nodes
  - Framing of a physical bit stream into a structure of frames/packets
  - Error control: Detection and correction
  - Connection setup and release
  - Acknowledgement-based protocols
  - Flow control
- Some ideas about how to use extended finite state machines to specify communication protocols



** Services                                                        

**** The link layer’s service

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Link layer sits on top of the physical layer
  - Can thus use a bit stream transmission service
  - But: this service might have incorrect bits; only between neighbors


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: The link layer between network and physical layer, bridging the gap between packets and bits
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:layers}
#+NAME: fig:ll:layers
[[./standalone/ll.pdf]]



\pause 

*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:

- Expectations of the higher layer (networking layer)
  - Wants to use either a packet service or, sometimes, a bit stream service (rather unusual)
  - Does not really want to be bothered by errors
  - Does not really want to care about issues at the other end



**** Requirement options for link layer service

- Dependable service – yes/no
  - Has many facets
    - A delivered packet should have the same content as the transmitted packet
    - All packets have to be delivered eventually
    - Packets have to be delivered in order
  - Error control may be required 
    - Forward error control, acknowledgements
- Connection-oriented – yes/no 
  - Is a *shared context* to/with the peer entity required?
- Packet or bitstream abstraction
  - Usually in computer networks: packets 
  - What about a maximal packet length? 


**** Distinguish: Service versus implementation
- Note the difference between service and implementation
- One example: 
  - Connection-less & reliable service required by the network layer
  - Link layer decides to use connections internally as a means to help with error control
- What about other combinations? 


**** Basic link layer functions – Framing 
- How to turn a physical layer’s bit stream abstraction into individual, well demarcated frames
  - Usually necessary to provide error control – not obvious how to do that over a bit stream abstraction
  - Frames and packets are really the same thing, only a convention to
    talk about ``frames'' in the link-layer context

\pause 
- In addition: Fragmentation & reassembly if network layer packets are longer than link layer packets

**** Basic link layer functions – Error control
- If desired by the network layer – usually is
- Usually built on top of frames 
- Error detection – are there incorrect bits?  
- Error correction – repair any mistakes that have happened? 
  - Forward error correction – invest effort before error happened; try to hide it from higher layers
  - Backward error correction – invest effort after error happened;
    try to repair it 

#+caption: Options for error control
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:errorcontrol}
#+NAME: fig:ll:errorcontrol
[[./standalone/ll.pdf]]



**** Basic link layer functions – Connection setup

***** \Gls{connection}                                         :B_definition:
      :PROPERTIES:
      :BEAMER_env: definition
      :END:

      \Glsdesc{connection}



*****                                                       :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:
- Connections useful for many purposes
  - Application context
  - Error control – several error control schemes rely on a *common context* between sender and receiver
- Question: how to *set up and terminate* a connection? What state information is required? 
  - Especially: if used on top of frames / packets? 
- Problem reappears later in the transport layer again, with some
  additional complications – treated there!

\pause 

***** Connection and circuit are very different!               :B_alertblock:
      :PROPERTIES:
      :BEAMER_env: alertblock
      :END:

Common confusion! 

**** Basic link layer functions – Flow control
- What happens with a fast sender and a slow receiver? 
- Sender will overrun buffers faster than the receiver can process the packets in that buffer
- Lots of transmission effort is wasted in this case
- Necessary to control the amount of frames a link layer sends per unit time, adapt to receiver’s capabilities
\pause 
- Problem reappears later in the transport layer again, with some
  additional complications – treated there!

***** \Gls{flowcontrol}                                        :B_definition:
      :PROPERTIES:
      :BEAMER_env: definition
      :END:

      \Glsdesc{flowcontrol}



** Framing                                                         

**** Framing
- How to turn a bit stream into a sequence of frames?
  - More precisely: how does a receiver know when a frame starts and when it finishes? 

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
  \node [label=left:{From PHY to link layer: }]  (bits) {0010100111011010011010111011101010010111};
  \draw [<-] ($(bits.south)+(-3,0)$) -- ++(0,-1) node [below, align=center] {Start of\\ frame?};
  \draw [<-] ($(bits.south)+(+3,0)$) -- ++(0,-1) node [below, align=center] {Ende of\\ frame?};
\end{tikzpicture}
\caption{Finding start and end of frames/pacekts in a sequence of bits}
\label{fig:ll:framing}
\end{figure}



\pause 

Note: Physical layer might try to detect and deliver bits when the sender is not actually transmitting anything
- Receiver still tries to get any information from the physical medium


**** Framing: Basic options 

- Put a length field into the packet header
  - What happens if bit errors inside this field?
- Use special bytes/bit sequences to indicate start or end
  - What happens if *these* sequences should be transmitted?
  - Common technique: *stuffing*
    - At bit or byte level
    - Sender deliberately modifies transmitted data to ensure that
      sequences do not appear in payload 
- Violate agreed-upon values (*coding violations*)
  - E.g., incorrect modulation patterns
  - Very robust, but very inefficient 


*** Old framing slides                                             :noexport:
**** Framing by character counting
- Idea: Announce the number of bits (bytes, characters) in a frame to the receiver
- Put this information into the frame
- Has to be at the beginning of a frame – a frame header
- 

**** Basic technique: Put control data into a header               :noexport:
- Albeit ``character count'' is not a good framing technique, it illustrates an important technique: headers
- If sender has to communicate administrative or control data to receiver, it can be added to the payload, the actual packet content
- Usually at the start of the packet; sometimes at the end (a trailer)
- Receiver uses headers to learn about sender’s intention
- Same thing works for packet headers as well
**** Framing by flag bytes/byte stuffing
- Use dedicated flag bytes to demarcate start/stop of a frame
- What happens when the flag byte appears in the payload? 
- Escape it with a special control character – byte stuffing
- If that appears, escape it as well
**** Framing by flag bit patterns/bit stuffing
- Byte stuffing is closely tied to characters/bytes as fundamental unit – often not appropriate
- Use same idea, but stick with the bit stream abstraction of the physical layer
- Use a bit pattern instead of a flag byte – often, 01111110
- Actually, it IS a flag byte
- Use bit stuffing
- Whenever sender sends five 1’s in a row, it automatically adds a zero into the bit stream – except in the flag pattern
- Receiver throws away (``destuffs'') any 0 after five 1’s
**** Framing by coding violations
- Suppose the physical layer’s encoding rules ``bits $\leadsto$ signals'' still provide some options to play with
- Not all possible combinations that the physical layer can express are used to express bit patterns
- Example: Manchester encoding – only low/high and high/low is used
- When ``violating'' these encoding rules, data can be transmitted – e.g., the start and end of a frame
- Example: Manchester – use high/high or low/low 
- This drops the self-clocking feature of Manchester, but clock synchronization is sufficiently good to hold for a short while
- Powerful and simple scheme – used e.g. by Ethernet networks 
- But raises questions regarding bandwidth efficiency


** Error control                                                   

**** Error control
- Two basic aspects:
  1. *Detect* the presence of errors (incorrectly received bits) in a frame 
  2. *Correct* errors in frames 
- Separate functions for error control
  - Detect, but do not correct
    - Typically, simply drop a frame; pretend that it never has arrived at the receiver
    - Higher layers can take corrective measures, if they so desire
  - Correct, but do not detect: Try to correct as many errors as possible, do not care if there are some remaining errors present
    - Only feasible if application is not (too much) bothered by errors
    - Example: voice applications can tolerate some degree of bits errors without loosing too much voice quality 
    - Functions for correction (very) inefficient if you only want to detect 
- Or combine both functions

**** Error control – redundancy 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Any form of error control requires redundancy in the frames
- Without redundancy
  - A frame of length $m$ can represent $2^m$ different frames
  - All of them are legal!


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   


#+caption: All possible frames are also legal frames, no redundancy
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:allframes}
#+NAME: fig:ll:allframes
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


- How could a receiver possibly decide that one legal frame is not the one that had originally been transmitted? 
- Not possible!
**** Error control – redundancy 

- Core idea: Declare some of the possible messages illegal!
  - Still need to be able to express $2^m$ legal frames
  - $\leadsto$ More than $2^m$ possible frames are required
  - $\leadsto$ More than $m$ bits are required in a frame  
  - Use frames with $n > m$ total length  
    - $r=n-m$ are the *redundant bits* (often, as header or trailer)
- Having *more possible than legal frames* allows receiver to detect
  illegal frames


#+caption: Distinguish between possible and legal frames
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:legalframes}
#+NAME: fig:ll:legalframes 
[[./standalone/econtrol.pdf]]



**** Simple redundancy example: Parity
- A simple rule to construct 1 redundant bit (i.e., $n=m+1$): Parity
  - Odd parity: Add one bit, choose its value such that the number of 1’s in the entire message is odd
  - Even parity: Add one bit, choose its value such that the number of 1’s in the entire message is even
- Example:
  - Original message without redundancy: ~01101011001~
  - Odd parity: ~01101011001~ *1* 
  - Even parity: ~01101011001~ *0*
**** How do illegal messages help with detecting bit errors?
- Transmitter only sends legal frame
- Physical medium/receiver might corrupt some bits
- *Hope*: A legal frame is only corrupted into an illegal frame
  - But one legal frame is never turned into another legal frame
- Necessary to realize this hope: 
  - Physical medium only alters up to a certain number of bits (by assumption) – say, $k$ bits per frame
    - *This is only an assumption!*
    - Alternative formulation: More than $k$ bit alternations have negligible probability 
    - How does it relate to the BER or the SNR? 
  - Legal messages are sufficiently different so that it is not possible to change one legal frame into another by altering at most k bits
**** Altering frames by changing bits
- Suppose the following frames are the only legal bit patterns: 0000, 0011, 1100, 1111
- Four-bit sequences form a hypercube when connecting sequences that
  only differ in a single position 


#+caption: Four-bit sequences arranged in a hypercube; neighbors are sequences that differ in at most a single bit position; blue circles show legal frame, orange circles differ from legal frames by one bit position, red circles differ in two bit positions (inspired by [[https://texample.net/tikz/examples/gray-code-in-4-cube/][Gray codes in TikZ]])
#+attr_latex: :width 0.95\textwidth :height 0.4\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:altering_frames}
#+NAME: fig:ll:altering_frames
[[./standalone/econtrol.pdf]]



*** Hamming distance 
**** Distance between frames
- In previous example: Two bit changes necessary to go from one legal frame to another
- Formally:  *\gls{hammingdistance} of two frames*
- Let $x=x_11,\dots, x_n$ and $y=y_1,…, y_n$ be two frames
- $d(x,y)$ = number of ``1'' bits in $x\, \mathrm{XOR}\, y$ 
  - Or: the number of bit positions where x and y are different


#+caption: Example for definition of Hamming distance 
#+name: tag:ll:hamming_definition 
#+ATTR_LATEX: :align rcl
| $x$                | = | 0011010111 |
| $y$                | = | 0110100101 |
|--------------------+---+------------|
| $x \,\mathrm{XOR}\, y$ | = | 0101110010 |
| $d(x,y)$           | = |          5 |




**** Hamming distance of a set of frames
- The \gls{hammingdistance} of a set of frames S: 

\[ d(S) =  \min _{x, y \in S, x \not = y} d(x,y)
\label{eq:hamming_distance}
\]

- The smallest distance between any two frames in the set

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


#+caption: Example for Hamming distance = 2
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:simple_hamming:1}
#+NAME: fig:ll:simple_hamming:1
[[./standalone/econtrol.pdf]]



***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Example for Hamming distance = 1
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:simple_hamming:2}
#+NAME: fig:ll:simple_hamming:2
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


 

** Forward error correction                                        

*** Basic correction 
**** \gls{hammingdistance} and error detection/correction
What happens if $d(S) = 0$?
  - This is nonsense, by definition

\pause 

What happens if $d(S) = 1$?

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}; }
\end{center}
#+end_export 

- There exist $x,y \in S$ such that $d(x,y) = 1$; no other pair is closer
- A single bit error converts from one legal frame $x$ to another legal frame $y$
- Cannot detect or correct anything
**** \gls{hammingdistance} and detection/correction
What happens if $d(S) = 2$?
  - There exist $x,y \in S$ such that $d(x,y) = 2$; no other pair is closer

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} 
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$u$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}
; }
\end{center}
#+end_export 

- In particular: any $u$ with $d(x,u) = 1$ is illegal, 
- I.e., errors that modify a single bit always lead to an illegal frame
- $\leadsto$ Error can be detected!
- Generalizes to all legal frames, because Hamming distance describes the ``critical cases''
- But not corrected – upon receiving u, no way to decide whether x or
  y had been sent (symmetry!)


**** \gls{hammingdistance} and detection/correction
What happens if $d(S) = 3$?
  - There exist $x,y \in S$ such that $d(x,y) = 3$; no other pair is closer
  - Every $u$ with $d(x,u)=1$ is illegal AND $d(u,s) > 1$! 

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} 
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$u$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$v$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}
; }
\end{center}
#+end_export 


- Hence: the receipt of u could have the following causes:
  - Originally, $x$ had been sent, but 1 bit error occurred
  - Originally, $y$ had been sent, but 2 bit errors occurred
  - (Originally, some other frame had been sent, but at least 2 bit errors occurred)
- Assuming that fewer errors have happened, a received frame $u$ *is presumed* to have been caused by sending $x$!
  - Hence, the error has been ``corrected'' – hopefully, correctly!

**** Generalization – Required \gls{hammingdistance}
- The examples above can be generalized
- To *detect* $d$ bit errors, a Hamming distance of $d+1$ in the set of legal frames is required
  - So that it is not possible to re-write a legal frame into another one using at most d bits
- To *correct* $d$ bit errors, a Hamming distance of $2d+1$ in the set of legal frames is required
  - So that all illegal frames at most $d$ bits away from legal frame are more than $d$ bits away from any other legal frame 
**** Frame sets – code books, codes

Some terminology: 
- The set of legal frames $S \in {0,1}^n$ is also called a *code book* or simply a *code*
- The *rate* $R_S$ of a code $S$ is defined as:
  \[  R_S = \frac{\log |S|}{n} \] 
  - Rate characterizes the efficiency
- The *distance* $\delta_S$  of a code $S$ is defined as: 
  \[ \delta_S  = \frac{d(S)}{n}\]
  - Distance characterizes error correction/detection capabilities

\pause 
A good code should have large distance and large rate – but arbitrary combinations are not possible
**** How to construct error correcting codes
- Constructing good codes (e.g., highest rate at given error correction needs) is difficult
- Simple example: use several parity bits
  - Distribute the parity bits over the entire codeword to protect against burst errors 
- Two main classes of actual codes
  - Block codes 
  - Convolutional codes

- Fancy techniques 
  - Turbo codes: generalization/successors to convolutional codes, almost capacity-achieving 
  - Low-Density Parity Check (LDPC): almost capacity-achieving 

**** Block codes: Bounds 
- Block codes operate on blocks of $k$ payload bits, outputting blocks of length $n$ by adding redundancy $r=n-k$
- Defining property: Output of $n bits *only* depends on these very $k$ input bits
- Each coded bit: XOR of several payload bits
  - Which payload bits get XOR'ed into which output bit defines the
    specific code as such 

#+caption: Block code turning blocks of $k$ payload bits into blocks of $n$ coded bits using XOR operations
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:block_code}
#+NAME: fig:ll:block_code
[[./standalone/econtrol.pdf]]




**** Bounds for block codes 
- Property: Binary block codes can correct up to t errors in a
  codeword of length n with k user bits only if (Varshamov-Gilbert
  bound):

\[ 
2^{n-k} \geq \sum _{i=0} ^t {n \choose i} 
\label{eq:varshamov:gilbert}
\]


-  But code for arbitrary  $(n, k, t)$ combination  does not necessarily exist



*** Detour: Polynomials                                            :noexport:


**** How to deal with error control mathematically 
- We need rules how to compute redundancy bits and how to interpret received sequence of (possibly erroneous) bits 
- For both error correction and error detection 
- Should be: 
- Efficiently implementable in hardware
- Provable properties! 
- Basic operation based on polynomial arithmetic
- Bit string is interpreted as representing a polynomial
- Coefficients 0 and 1 are possible, interpreted modulo 2
- As are groups of bits
- Interpreted than as modulo 2^k 
  - 
**** Modulo 2 arithmetic 
- With 0 and 1 as the only possible numbers (bits!), normal arithmetic is not applicable
- Instead: look at modulo 2 arithmetic
- Rules: 
- Addition modulo 2 Subtraction modulo 2Multiplication modulo 2
- Example: 0110111011 
-                 ©  1101010110 = 1011101101
**** Matrix multiplication 
- With addition and multiplication in place, we can define matrix multiplication quite easily 
- 
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 38
**** Modulo 2 division
- Division of two numbers is done just like normal division
- 1101010110 / 1001 = 1100110  1001
-       1000
-       1001
-         001101
-             1001
-               1001
-               1001
-                   
**** Modulo 2 division with remainder
- After division, a remainder may result 
- 1101010101 / 1001 = 1100110  remainder 11  1001
-       1000
-       1001
-         001101
-             1001
-               1000
-               1001
-                 0011
**** Polynomials over modulo 2 arithmetic
- Define polynomials over modulo 2 arithmetic
- p(x) =  an ¢ xn © … © a1 x1 © a0
- Coefficients and x 2 {0,1}
- Addition, subtraction, multiplication and division of polynomials is defined in the usual way!
- Using modulo 2 arithmetic, of course 
**** Bit strings and polynomials modulo 2
- Idea: Conceive of a string of bits as a representation of the coefficients of a polynomial
- Bit string: bnbn-1…b1b0
- Polynomial: bn¢xn © … © b1¢x1 © b0
- A bit string of (n+1) bits corresponds to a degree n polynomial!
- Operations on bit strings correspond to operations on polynomials and vice versa
- Example: ``Add k zeros'' $ ``multiply by xk''
- This isomorphism allows us to divide bit strings!
- 
**** Generalization: Groups of bits 
- Instead of looking at polynomials over just 0/1 (the GF(2) Galois Field), we can also group bits together 
- Popular choice: group 8 bits together 
- Galois Field GF(2^8)
- Also called Rijndael‘s finite field 
- Addition, subtraction work similarly, multiplication of polynomials becomes a bit more complicated 
- Practically, often more suitable than working on bit sequences 
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 43


*** Matrixes 


**** Notation for block codes: one output bit  

- Output bit of a block code: XOR of several payload bits
  - E.g.: $o = x_1 \,\mathrm{XOR}\, x_5  \,\mathrm{XOR}\, x_7 \,\mathrm{XOR}\, x_8$ 
\pause 
- Equivalent: Sum of these payload bits, modulo 2 
  - E.g., $o = (x_1 + _x5 + x_7 + x_8) \, \mathrm{MOD}\, 2$
\pause 
- Which payload bits: multiply by zero or one 
  - E.g., $o = (0\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  0 \cdot x_4 + 1 \cdot x_5 + 0 \cdot x_6 + 1 \cdot  x_7 + 1\cdot  x_8) \, \mathrm{MOD}\, 2$

**** Notation for block codes: several  output bits 

E.g.: 

- $o_0 = (0\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  0  \cdot x_4 + 1 \cdot x_5 + 0 \cdot x_6 + 1 \cdot  x_7 + 1 \cdot x_8) \, \mathrm{MOD}\, 2$
- $o_1 = (1\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  1  \cdot x_4 +0 \cdot x_5 + 1 \cdot x_6 + 1 \cdot  x_7 + 0 \cdot x_8) \, \mathrm{MOD}\, 2$
- $o_2 = (0\cdot x_0 + 0\cdot  x_1 + 1 \cdot x_2 + 0 \cdot x_3 +  1  \cdot x_4 + 1 \cdot x_5 + 0 \cdot x_6 + 0 \cdot  x_7 + 0 \cdot x_8) \, \mathrm{MOD}\, 2$
- \dots 
\pause 

That can be written more compactly as a matrix mutliplication 

**** Notation for block codes: matrix representation 


\[
(x_0 x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9)  \cdot 
\begin{pmatrix}
  0 & 1 & 0 & \dots \\
  1 & 1 & 0 & \dots \\
  0 & 0 & 1 & \dots \\
  0 & 0 & 0 & \dots \\
  0 & 1 & 1 & \dots \\
  1 & 0 & 1 & \dots \\
  0 & 1 & 0 & \dots \\
  1 & 1 & 0 & \dots \\
  1 & 0 & 0 & \dots \\
\end{pmatrix} = ( o_0 o_1 o_2 \dots o_n)
\label{eq:block_matrix}
\]


**** Codes as matrix operations: nonsystematic code 

- What is a *suitable* matrix to compute coded bits? 
- In general: a *nonsystematic code* 
  - Using a *\gls{generator} matrix*
- Given payload $p$, find *\gls{codeword}* c using generator $G$ as $c = pG$ 
- Example: 

\[
\underbrace{( 1 0 0 1)}_{\mathrm{Payload}} \cdot
\underbrace{\begin{pmatrix}
0 & 1&1 &0 &1 &1 &0 \\
1 & 1&0 &1 &1 &0 &0 \\ 
1 & 0& 1& 1& 0& 1& 1  \\
0 &0 &0 &1 &0 &0 &0  \\
\end{pmatrix}}_{\mathrm{Generator }\,G} = 
\underbrace{(0 1 1 1 1 1 0 )}_{\mathrm{Codeword}}
\]



**** Codes as matrix operations: Systematic codes 
- Let’s look at generator matrix with a particular structure 
  - Identity matrix $I_k$, append matrix for $A$ parity bits 
  - For $k$ payloads, and $(n-k)$ redundancy bits, $A$ is a $(k, n-k)$
    matrix 
  - $G = (I_k | A)$

- Example 

\[
\underbrace{( 1 0 0 1)}_{\mathrm{Payload}} \cdot
\underbrace{\begin{pmatrix}
1 & 0& 0 &0 & | & 1 &1 &0 \\
0 & 1&0 &0 & | & 1 &0 &0 \\ 
0 & 0& 1& 0 & | & 0& 1& 1  \\
0 &0 &0 &1  & | & 0 &0 &0  \\
\end{pmatrix}}_{\mathrm{Generator }\,G} = 
\underbrace{(1 0 0 1 |  1 1 0)}_{\mathrm{Codeword}}
\]



**** Decoding of systematic codes? 
- Encoding is easy – how about decoding? 
  - Getting back the original payload from the (possibly erroneous) received bits 
- Use a *parity-check matrix* $H$ 
  - For $k$ payloads and $n-k$ redundancy bits, $H$ is an $(n-k, n)$
    matrix
    - \pause Write a generator $G$ using $A$:  \[ G = (I_k | A)\] 
    - \pause Then define $H$: \[ H = (-A^T | I_{n-k})  \] 
  - \pause Use this to show: 
    \[  G H^T = 0   \]


**** Parity-check property 
- For a *valid* codeword $c$, it must hold:
  \[ H c^T = 0 \]
  - Hence:  if result <> 0, codeword is not valid
- One way to check for errors (but not a particularly efficient one, if error checking is all you want to do) 



**** Example: Hamming (7,4) code                                   :noexport:



**** Decoding: Maximum likelihood decoding 
- Suppose we received an invalid codeword $c$ 
  - We want to map it to original payload 
  - Under stochastic assumptions: errors happened randomly 
- What is then the ``right'' answer, the ``right'' payload to identify? 
- Simple approach:
  - For each payload, there is a likelihood that we received that invalid $c$ 
    - Under stochastic assumptions how errors happen
  - We decide for that payload that maximizes this likelihood (maximum likelihood decoding) 
  - Under independent bit errors: the one with the smallest \gls{hammingdistance}! 
\pause 
- Details: highly depends on specific code family 

**** Maximum likelihood decoding: How?                             :noexport:
- Trivial approach: Search through all codewords around the received (invalid) codeword c 
- Akin to an expanding ring search: Hamming distance 1, 2, \dots 
- Simple, but sloooow 
- Efficient? 
- Syndrome decoding 
- Iterative algorithms, often amenable to hardware implementations
- For details, check lecture Blömer Codes & Crypto 


*** BCH 
**** Block code examples 

- Bose Chaudhuri Hocquenghem (BCH) codes – based on polynomials over finite fields 
- Reed Solomon codes (special case of non-binary BCH codes)



**** Example: BCH codes 
- Family of binary block codes 
  - Binary: polynomials with coefficients 0 and 1 (over GF(2))
- BCH: Bose & Chaudhuri [[cite:&Bose1960-br]], Hocquenghem \cite{hocquenghem59:_codes}
- Properties: For any integer $m > 2$ and $t < 2m-1$, there exist a BCH code with 
  - Block length: $n = 2m -1$
  - Number of parity-check digits: $n-k \leq mt$ 
    - With tight bound for small $t$ 
  - Minimum Hamming distance: $d >= 2t + 1$
    - I.e., can correct up to $t$ errors 
  - (k: number of payload bits)
- Interpretation: Bound on how many payload bits, given desired error correction capability 


**** BCH parameters

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- Issue: no simple formulas to compute $n-k$
- Example values for n, k, t  

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

 

\begin{table}[htbp]
\caption{\label{tab:ll:bch}Example combinations for BCH codes with codeword length 127}
\centering
  \maxsizebox{!}{0.3\textheight}{
\begin{tabular}{rrr}
Codeword length \(n\) & Payload \(k\) & Correctable errors \(t\)\\
\hline
127 & 120 & 1\\
127 & 113 & 2\\
127 & 106 & 3\\
127 & 99 & 4\\
127 & 92 & 5\\
127 & 85 & 6\\
127 & 78 & 7\\
127 & 71 & 9\\
127 & 64 & 10\\
127 & 57 & 11\\
127 & 50 & 13\\
127 & 43 & 14\\
127 & 36 & 15\\
127 & 29 & 21\\
127 & 22 & 23\\
127 & 15 & 27\\
127 & 8 & 31\\
\end{tabular}}
\end{table}



**** Example: Reed-Solomon codes 
- Generalization of BCH codes to non-binary symbols 

- Applications: 
  - Data storage – RAID, CDs, DVDs
  - Some simple data transmission techniques 

**** Block error rate for BCH codes

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Block is considered in error if any bit errors remain after correction 
- Example: codewords 127 bit, varying number of correctable bit errors (``c'' in legend)




***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   


#+caption: Packet error rate achieved by BCH codes for varying number of correctable errors $t$ as function of signal-to-noise ratio
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:per_over_snr}
#+NAME: fig:ll:per_over_snr
[[./standalone/bch.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Coding gain 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


Note: 
- the roughly parallel curves, once SNR gets ``good enough''
- double logarithmic axes 

\pause 
Gives rise to notion of *coding gain*
- The factor of SNR needed to get the same PER from two different
  codes 



***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Coding gain: Factor between two SNR needed by two dfiferent FEC schemes to obtain comparable PER
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:per_over_snr:with_coding_gain}
#+NAME: fig:ll:per_over_snr:with_coding_gain
[[./standalone/bch.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


**** Coding gain 

***** \Gls{codinggain}                                         :B_definition:
      :PROPERTIES:
      :BEAMER_env: definition
      :END:

      \Glsdesc{codinggain}


*** Convolutional codes 
**** Convolutional codes

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- Block codes: *one* block of payload bits determines *one* block of
  coded bits 
  - There is no history; previous bits do not matter
- Convolutional codes: Take into account a couple of previous payload
  blocks as well
  - Otherwise, quite similar
  - Payloads in blocks of $k$ bits, $n$ output bits determined from
    the last $K\cdot k$ bits
    - $K > 1$: constraint length 
  


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   



#+caption: Structure of convolutional code for payload block length $k$, output block length $n$ , and constraint length $K$
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:convolutional_code}
#+NAME: fig:ll:convolutional_code
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Decoding convolutional codes – Viterbi algorithm
- Encoding convolutional codes is trivial
  - simple shift register (just like block codes)
- Decoding? 
- Popular: *Viterbi algorithm* [[cite:&Viterbi1967-gv]]
  - *Dynamic programming* technique
  - Idea: hidden (for the receiver) sequence of states (= sent bits), receiver observes sequence of events (= received bits)
  - Viterbi algorithm determines the most likely sequence of states that has caused the observed sets of events 
  - *Maximum likelihood property* makes this algorithm powerful
  - Can be nicely implemented in hardware, but costly (*large* chip area!)


**** Convolutional codes: Properties 
- Still popular codes in wireless transmission 
  - Relatively close to Shannon bound/channel capacity!
  - Allow plenty of additional tricks, e.g., puncturing 
- Typical examples: 
  - Turbo codes: Two convolutional codes nested within each other, informing each other over error patterns
    - Used in UMTS, LTE, \dots 
- Low-density parity check codes
  - Tend to outperform Turbo codes at higher code rates
  - Used e.g. in DVB-S2, 10G Ethernet, \dots optional in 802.11n, 11ac



**** An additional trick: Interleaving                             :noexport:
- How to deal with burst errors? Spanning multiple code blocks?  
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 60

** Error detection                                                 


**** How to construct error detecting codes – CRC 
- Efficient error detection: *Cyclic Redundancy Check*  (CRC)
- Gives rules how to compute redundancy bits and how to decide whether a received bit pattern is correct
  - Very high detection probability with few redundancy bits
  - Efficiently implementable in hardware
- Basic operation based on polynomial arithmetic
  - Bit string is interpreted as representing a polynomial
  - Coefficients 0 and 1 are possible, interpreted modulo 2

**** Use polynomials to compute redundancy bits – CRC 
- Define a generator polynomial $G(x)$ of degree $g$
  - I.e., it needs $g+1$ bits for all coefficients 
  - We will use $g$ redundancy bits in the end
  - Known to both sender and receiver
- Given: message/frame $M$, represented by polynomial $M(x)$
- Transmitter
  - Compute remainder $r(x)$ of division $(x^gM(x)) / G(x)$
  - Note: Remainder after division is of degree $< g$, fitting into $g$ bits!
  - Transmit $T(x) = (x^gM(x))  - r(x)$ 
  - Note: $(x^gM(x)) - r(x)$ is divisible *without remainder* by $G(x)$
- Receiver
  - Receive $m(x)$
  - Compute remainder of division of $m(x)$ by $G(x)$

**** CRC transmission and reception
- What happens in the channel after transmitting $T(x)$?
  - No errors: $T(x)$ arrives correctly at the receiver
  - Bit errors occur: $T(x)$ is modified by flipping some bits 
  - Equivalent to modifying some coefficients of the polynomial
  - Equivalent to *adding an error polynomial* $E(x)$
- At the receiver, $m(x) = T(x) + E(x)$ arrives
  - Compute remainder of division of $m(x)$ by $G(x)$
    - No errors: $m(x) = T(x)$; remainder is zero!
  - Bit errors: 

\[m(x)/G(x) = (T(x) + E(x))/ G(x) = 
\underbrace{T(x)/G(x)}_{\text{no remainder}} + 
\underbrace{E(x)/G(x)}_{\text{SHOULD have non-zero remainder!}}
\]
**** CRC – Overview 

#+caption: OVerview of CRC at transmitter, channel, and receiver
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:crc}
#+NAME: fig:ll:crc
[[./standalone/econtrol.pdf]]



**** Choice of G(x) determines CRC properties

- When is remainder of $E(x) / G(x) \not= 0$?
  - If $G(x)$ divides $E(x)\not=0$ without remainder, an error slips
    through!
\pause
- Single bit error: $E(x) = x_i$ for error at position $i$
  - $G(x)$ needs two or more terms to ensure that $E(x)$ is not a multiple of it
\pause
- Two bit errors: $E(x) = x_i + x_j = x_j \cdot (x_{i-j} +1)$ for some $i>j$
  - $x$ must not divide $G(x)$
  - $G(x)$ must not divide $(x_k + 1)$ for all $k$ up to, e.g., maximum frame length
\pause
- Odd number of errors: $E(x)$ has an odd number of terms
  - $E(x)$ will NOT have $(x+1)$ as a factor (simple proof by contradiction)
  - Make $(x+1)$ a factor of $G(x)$ so that it cannot divide $E(x)$
\pause
- Using $r$ check bits, all burst errors of length $\leq r$ can be
  detected 

**** Practical CRC 
- Practically used generator polynomial (IEEE 802):
  - $x_{32} + x_{23} +  x_{16} + x_{12} + x_{11} + x_{10} + x_8 + x_7 + x_5 + x_4 + x_2 + x_1 + 1$
- In practice, residual errors after CRC check are ignored
  - But they may still happen!
  - In particular, when bit errors are not independent, but bursty
- Implementation in hardware: shift register circuit
  - Negligible overhead in hardware, time, energy 


** Backward error correction

*** ARQ                                                            

**** How to handle detected errors? 
- Suppose the CRC function detects an error 
  - Sometimes, delivering incorrect frame is acceptable
  - Typically, have to repair the error somehow 
- *Backward* error recovery
  - Take action *after* the error has occured 
- Here: frame has to be retransmitted
- How to tell the sender? 

  
**** A simple, simplex, acknowledgement-based protocol
- Acknowledge to sender the receipt of a packet
  - Sender waits for acknowledgement for a certain time
  - If not received in time, packet is retransmitted
\pause 

***** \Gls{arq}                                                :B_definition:
      :PROPERTIES:
      :BEAMER_env: definition
      :END:

      \Glsdesc{arq}


**** A simple, simplex, acknowledgement-based protocol

First solution attempt



***** Sender (ARQ, v1)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

#+caption: Sender in a simple backward error recovery protocol
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:arq:simple_sender}
#+NAME: fig:arq:simple_sender
[[./standalone/arq_fsm.pdf]]



***** Receiver (ARQ, v1)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Receiver in a simple backward error recovery protocol
#+attr_latex: :width 0.95\textwidth :height 0.5\textheight :options keepaspectratio,page=\getpagerefnumber{page:arq:simple_receiver}
#+NAME: fig:arq:simple_receiver
[[./standalone/arq_fsm.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Protocol analysis
- This protocol is nice and simple, but flawed in multiple ways
  - What happens when the higher layer sends packets faster than the acknowledgements come in (and when one is missing?)
  - What happens if acknowledgements are lost?
- $\leadsto$ Need some fixes for the protocol here…


**** Acknowledgement-based protocol, second trial
- Cure one problem: Concentrate on one packet, only accept the next packet from higher layer when previous one has been fully processed

\pause 

Second solution attempt: 

***** Sender (ARQ v2)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.68
      :END:

#+caption: Sender that drops packets from higher layer while busy processing a previous packet
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:arq:sender_process}
#+NAME: fig:arq:sender_process
[[./standalone/arq_fsm.pdf]]



***** Receiver (ARQ v2)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.28
      :END:   


Receiver: Identical to previous version! 

*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


**** Does second version work correctly?

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- It holds back the transmitter until packets are processed
  - It implements *flow control*!
- Does it ensure that all packets arrive, in correct order? 


****** No packets lost, using ARQ v2
#+caption: No packet loss, correct operation with v2 of our protocol
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:arq:no_seq}
#+NAME: fig:ll:arq:no_seq
[[./standalone/arq_msc.pdf]]



***** One packet loss 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Loosing one packet can be recovered by timeout in the v2 protocol
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:arq:no_seq:packet_lost}
#+NAME: fig:ll:arq:no_seq:packet_lost
[[./standalone/arq_msc.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:




**** Does second version work correctly? 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- Simple cases seem ok
- What if an acknowledgement is lost? 


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Loosing an acknowledgement leads to timeout as well and then to duplicate delivery of the same packet to the upper layer; v2 fails
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:arq:no_seq:arq_lost}
#+NAME: fig:ll:arq:no_seq:arq_lost
[[./standalone/arq_msc.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:




**** Problem of second version
- Sender cannot distinguish between a lost packet and a lost acknowledgement $\leadsto$ has to re-send the packet
- Receiver cannot distinguish between a new packet and a redundant copy of an old packet
-  $\leadsto$ Additional information is needed 
  

**** Sequence numbers

- Put a *sequence number* in each packet, telling the receiver which packet it is
  - Sequence numbers as header information in each packet 
  - Simplest sequence number: a single bit, 0 or 1!
- Needed in packet & acknowledgement 
  - In Ack, convention: send the sequence number of the last correctly received packet back
  - Also possible: send sequence number of next expected packet 
- Retransmissions are usually *not* distinguished from the original
  packet     

**** Acknowledgements & sequence numbers – 3rd version

\vskip-2.5em

***** Sender (v3)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.68
      :END:


#+caption: Sender of an alternating bit protocol with simple flow control
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:arq:sender_alternating_bit}
#+NAME: fig:arq:sender_alternating_bit
[[./standalone/arq_fsm.pdf]]



***** Receiver (v3)
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.28
      :END:   

#+caption: Receiver of an alternating-bit protocol
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:receiver_alternating_bit}
#+NAME: fig:ll:receiver_alternating_bit
[[./standalone/arq_fsm.pdf]]


*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Assessment of 3rd version – Alternating bit protocol
- This 3rd version is a correct implementation of a dependable protocol over an error-prone channel
  - Protocol name: *Alternating bit protocol*
    - As it uses only a single bit as sequence number 
  - It also implements a simple form of flow control
\pause 
- Note the dual task of the acknowledgement packet
  - It *confirms* to the sender that the receiver has obtained a certain packet
  - It  *permits*  sending the *next* packet, stating that the receiver has the capacity to handle it
  - \pause These two functions can be and are separate in other protocols!

*** Efficiency 

**** Alternating bit protocol – Efficiency  
\vskip-3.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- *Efficiency* \rho depends on setting 
- $\rho$:  ratio of time during which the sender sends *new* information
  - Assuming an error-free channel in the simplest case; error-considerations make efficiency discussions difficult
  - Then: $\rho = T_\mathrm{packet}  / (T_\mathrm{packet} + d + T_\mathrm{ACK} + d)$ 
- Efficiency of simple alternating bit protocol is low when *delay is large compared to data rate*
  - Equivalently: at large ``bandwidth''-delay product!


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Efficiency of an alternating bit protocol in an error-free case
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:alternating_bit_efficiency}
#+NAME: fig:ll:alternating_bit_efficiency
[[./standalone/arq_msc.pdf]]


*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:




**** Improving efficiency – have more ``outstanding'' packets


\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.58
      :END:

- Inefficiency of alternating bit in large bandwidth-delay situations is owing to not exploiting ``space'' between packet and acknowledgement 
- Always sending packets should improve  efficiency
  - More packets are ``outstanding'', ``in flight'' = sent, but not yet acknowledged
  - ``Pipelining'' of packets
\onslide<2-> 
- But not feasible with a single bit as sequence number
  - $\leadsto$ Needs larger sequence number space! 
  - It is simplified by full-duplex support

\onslide<1-> 

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.38
      :END:   

#+caption: Efficent ARQ protocol in large bandwidth-delay product settings as long as many packets can be in flight (which requires large sequence number space)
#+attr_latex: :width 0.95\textwidth :height 0.5\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:packets_in_flight}
#+NAME: fig:page:ll:packets_in_flight
[[./standalone/arq_msc.pdf]]


*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


**** Sender-side sliding window to handle multiple outstanding packets
- Introduce a larger sequence number space to distinguish any possible
  in-flight packets 
  - Say, $n$ bits or $2^n$ sequence numbers 
\pause 
- Not all of them may be allowed to be used simultaneously
  - Recall alternating bit case: 2 sequence numbers, but only 1 may be
    ``in transit''
\pause 
- Recall: Channel have an implicit ``storage capacity''
  - Sender should not exceed that; that would surely lead to packet
    loss 
\pause 
- Use *sender-slide sliding window* of sequence numbers describe which
  packets a sender may have in flight
  - Often cast as: The set of sequence number still allowed to send 


**** Manipulating sender-side windows 

- Acknowledgement arrives at sender 
  - Indicates to sender the  some packet has left the network
    - (implicit channel storage is less used)
  - Typically shifts the sliding window, allowing new packet(s) to be sent
\pause 
- Timeout
  - Triggers retransmission
  - Usually ok, since timeout also means: packet has left the network
    (by being lost)



**** Receiver-side sliding window to manage buffers 

- Sliding window at receiver
  - Set of sequence numbers receiver is willing to accept at given time
  - Usually governed by available buffer space at receiver
- May be fixed in size or adapt dynamically over time

**** Sliding window – simple example                               :noexport:
- A simple sliding window example for n=3, window size fixed to 1
- Sender here represents the currently unacknowledged sequence numbers (``in flight'') 



**** Transmission errors and receiver window size

Assumptions: 
- Link layer should deliver all frames correctly and in sequence
- Sender is pipelining packets to increase efficiency
- What happens if packets are lost (discarded by CRC)? 
- With receiver window size 1, all following packets are discarded as well!




**** Example: Receiver window size 1 - Go-back-N

- With receiver window size 1, all *frames following a lost* frame cannot be handled by receiver
  - They are *out of sequence*
- Since we have no buffer (window size=1!), we have to discard them 
  - They cannot be acknowledged,
  - If desired: can send  ACKs for the last correctly received packet can be sent
    - A so-called *cumulative ACK* for *all* correctly received
      sequence numbers 
- Sender will timeout eventually
  - Since *all* frames sent after the timed-out one have been
    discarded by receiver , they have to be repeated
  - Hence: $\leadsto$ Go-back N (frames)! 
- Assessment
  - Quite wasteful of transmission resources
  - But saves overhead at the receiver 

**** Example: Sender window size 3, receiver window size 1 

\vskip-2.5em

***** Go-Back-N 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


- Sender allowed to have up to three packets in flight
- Receiver will only accept the *next packet in sequence* 
  - Discards any out of order packet
  - But does send CumAcks back 




*****  Example trace
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

\begin{figure}[h]
  \centering
  \maxsizebox{!}{0.6\textheight}{
  \begin{tikzpicture}
  \label{page:ll:gobackn}
  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-25); 
  \draw (b) -- ++(0,-25);

  \pplusa{0}{hpiorange!30}{2}{0.25}{1}{}
  \node [left=0.1 of pStartSend_1, align=right] {Send window=3, reduce to 2};
  \node [right=0.1 of pEndReceive_1, align=left] {Expected P1, got P1, deliver}; 

\onslide<2->
  \pplusa{2.5}{hpiblue!30}{2}{0.25}{2}{}
  \node [left=0.1 of pStartSend_2, align=right] {Send window=2, reduce to 1};
  \node [right=0.1 of pEndReceive_2, align=left] {Expected P2, got P2, deliver}; 

\onslide<3->
  \pplusa{5}{hpiyellow!30}{2}{0.25}{3}{X}
  \node [left=0.1 of pStartSend_3, align=right] {Send window=1, reduce to 0};

\onslide<4->
  \node [left=0.1 of aEndReceive_1, align=right] {Increase send window to 1};


\onslide<5->
  \pplusa{7.5}{hpired!30}{2}{0.25}{4}{}
  \node [left=0.1 of pStartSend_4, align=right] {Send window=1, reduce to 0};

\onslide<6->
  \node [left=0.1 of aEndReceive_2, align=right] {Increase send window to 1};


\onslide<7->
  \pplusa{10}{hpiorange!80}{2}{0.25}{5}{}
  \node [left=0.1 of pStartSend_5, align=right] {Send window=1, reduce to 0};

\onslide<8->
  \node [right=0.1 of pEndReceive_4, align=left] {Expected P3, got P4, discard, CumAck=2}; 


\onslide<9->
  \node [left=0.1 of pEndSend_5, align=right] {Timeout for ACK 3!};

\onslide<10->
  \pplusa{12.5}{hpiblue!80}{2}{0.25}{3b}{}
  \node [left=0.1 of pStartSend_3b, align=right] {Retransmit 3, send window stays at 0};

\onslide<11->
  \node [right=0.1 of pEndReceive_5, align=left] {Expected P3, got P5, discard, CumAck=2}; 

\onslide<12->
  \node [left=0.1 of pEndSend_3b, align=right] {Timeout for ACK 4!};
  \pplusa{15}{hpiyellow!80}{2}{0.25}{4b}{}
  \node [left=0.1 of pStartSend_4b, align=right] {Retransmit 4, send window stays at 0};

\onslide<13->
  \node [right=0.1 of pEndReceive_3b, align=left] {Expected P3, got P3b, deliver, send CumAck=3}; 

\onslide<14->
  \node [left=0.1 of pEndSend_4b, align=right] {Timeout for ACK 5!};
  \pplusa{17.5}{hpired!80}{2}{0.25}{5b}{}
  \node [left=0.1 of pStartSend_5b, align=right] {Retransmit 5, send window stays at 0};


\onslide<15->
  \node [left=0.1 of aEndReceive_3b, align=right] {Increase send window to 1};

\onslide<16->
  \node [right=0.1 of pEndReceive_4b, align=left] {Expected P4, got P4b, deliver, send CumAck=4}; 

\onslide<17->
  \pplusa{20}{green!20}{2}{0.25}{6}{}
  \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};


\onslide<18->

  \node [right=0.1 of pEndReceive_5b, align=left] {Expected P5, got P5b, deliver, send CumAck=5}; 


\end{tikzpicture}}
\caption{Go-Back-N example. Note: sequence numbers 3b, 4b, 5b only shown for better illustrations; real packet sequence numbers do \textbf{not} distinguish between original and retransmission.}
\label{fig:ll:gobbackn}
\end{figure}
*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:





**** Selective repeat
- Suppose we invest a bit into a receiver to  intermittently buffer packets if some packets are missing
  - Corresponds to receiver window larger than 1
\pause 
- Resulting behavior:
  - Receiver should  inform sender about all packets it has received
    already (to avoid needless retransmissions)
  - Often realized by mix of:
    - *CumAcks* for all packets in sequence 
    - plus *Selective Ack* for additionally received frames 
  - Sender selectively repeats the missing frames 
- Once missing frames arrive and close gaps in packet sequence, they
  are all passed to up the network layer

**** Example selective repeat: Sender window=3, receiver window=\infty 


\begin{figure}[h]
  \centering
  \maxsizebox{!}{0.6\textheight}{
  \begin{tikzpicture}
  \label{page:ll:selective_repeat}
  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-25); 
  \draw (b) -- ++(0,-25);


  \pplusa{0}{hpiorange!30}{2}{0.25}{1}{}
  \node [left=0.1 of pStartSend_1, align=right] {Send window=3, reduce to 2};
  \node [right=0.1 of pEndReceive_1, align=left] {Expected P1, got P1, deliver, CumAck=1}; 
\pause
  \pplusa{2.5}{hpiblue!30}{2}{0.25}{2}{}
  \node [left=0.1 of pStartSend_2, align=right] {Send window=2, reduce to 1};
  \node [right=0.1 of pEndReceive_2, align=left] {Expected P2, got P2, deliver, CumAck=2}; 
\pause
  \pplusa{5}{hpiyellow!30}{2}{0.25}{3}{X}
  \node [left=0.1 of pStartSend_3, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_1, align=right] {Increase send window to 1};
\pause
  \pplusa{7.5}{hpired!30}{2}{0.25}{4}{}
  \node [left=0.1 of pStartSend_4, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_2, align=right] {Increase send window to 1};  
\pause
  \pplusa{10}{hpiorange!80}{2}{0.25}{5}{}
  \node [left=0.1 of pStartSend_5, align=right] {Send window=1, reduce to 0};
\pause
  \node [right=0.1 of pEndReceive_4, align=left] {Expected P3, got P4, buffer P4, CumAck=2 + NACK=3, SelAck=4}; 
\pause
  \node [left=0.1 of pEndSend_5, align=right] {Timeout for ACK 3!};
  \pplusa{12.5}{hpiblue!80}{2}{0.25}{3b}{}
  \node [left=0.1 of pStartSend_3b, align=right] {Retransmit 3, send window stays at 0};
\pause
  \node [right=0.1 of pEndReceive_5, align=left] {Expected P3, got P5, buffer P5, CumAck=2 + NACK=3, SelAck=4,5}; 
\pause
  \node [left=0.1 of aEndReceive_4, align=right] {NACK 3 provides no new information, already retransmitted, SelAck 4 increases SendWindow to 1};
\pause
  \pplusa{15}{hpiyellow!80}{2}{0.25}{6}{}
  \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_5, align=right] {NACK 3 provides no new information, already retransmitted, SelAck 5 increases SendWindow to 1};
\pause
  \node [right=0.1 of pEndReceive_3b, align=left] {Expected P3, got P3b, deliver 3, 4, 5, send CumAck=5}; 
\pause
  \pplusa{17.5}{hpired!80}{2}{0.25}{7}{}
\pause
  \node [right=0.1 of pEndReceive_6, align=left] {Expected P6, got P6, deliver 6, send CumAck=6}; 

%----------------------------------
%   \pplusa{20}{green!20}{2}{0.25}{8}{}

%   Sender comments:
  
  
  % \node [left=0.1 of pStartSend_4b, align=right] {Retransmit 4, send window stays at 0};
  % \node [left=0.1 of pStartSend_5b, align=right] {Retransmit 5, send window stays at 0};

  % \node [left=0.1 of aEndReceive_3b, align=right] {Increase send window to 1};
  
  % \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};

  % Receiver comments: 

  



  
  % \node [right=0.1 of pEndReceive_4b, align=left] {Expected P4, got P4b, deliver, send CumAck=4}; 

  % \node [right=0.1 of pEndReceive_5b, align=left] {Expected P5, got P5b, deliver, send CumAck=5}; 
  
\end{tikzpicture}
}
\caption{Selective repeat example. Note: sequence numbers 3b, 4b, 5b only shown for better illustrations; real packet sequence numbers do \textbf{not} distinguish between original and retransmission.}
\label{fig:ll:selective_repeat}
\end{figure}



**** Duplex operation and piggybacking 
- So far, simplex operation at the (upper) service interface was assumed
  - The receiver only sent back acknowledgements, possibly using duplex operation of the lower layer service
- What happens when the upper service interface should support full-duplex operation?
  - One option: Use two separate channels for each direction – wasteful
  - Better: Interleave acknowledgement and data frames in a given direction
  - Best (and usual): Put the acknowledgement information for direction A! B into the data frames for B $\leadsto$ A 
  - As part of B’s header – piggyback it 



*** FEC and ARQ
**** Combine FEC and ARQ?
- If ARQ used, does FEC still make sense? 
  - Yes, depending on the error situation
- Trade-off:
  - With stronger FEC, packet error rate reduces, fewer retransmissions
  - But also fewer /payload/ bits per fixed-size codeword, fixed-size
    header overhead 


**** Combine FEC and ARQ? – Performance 

- Codewords 127 bit, varying number of correctable bit errors (``t'' in legend)
- For at varying SNR, AWGN channel, BPSK modulation, infinitely many
  retransmissions 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.28
      :END:

#+caption: PER over SNR (repetition of Figure \ref{fig:ll:per_over_snr:with_coding_gain})
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:per_over_snr}
#+NAME: fig:ll:per_over_snr_2
[[./standalone/bch.pdf]]



***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.68
      :END:   

#+caption: Throughput over SNR, for varying number of correctable bit errors
#+attr_latex: :width 0.95\textwidth :height 0.5\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:thoughput_over_snr}
#+NAME: fig:ll:thoughput_over_snr
[[./standalone/bch.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:




** Conclusion 



**** Conclusion
- Most problems in the link layer are due to errors
  - Errors in synchronization require non-trivial framing functions
  - Errors in transmission require mechanisms to correct them so as to hide from higher layers
  - Or to detect them and repair them afterwards
- Flow control is often tightly integrated with error control in practical protocols
  - But it IS a separate function and can be realized separately as well
- Connection setup/teardown still has to be treated
  - Necessary to initialize a joint context for sender and receiver


*** ARQ tests                                                      :noexport:



#+BEGIN_EXPORT latex

\newcommand{\pplusa}[6]{%
  % #1: offset, #2: fill color #3: packet length #4: ACK length, #5 label
  % #6: X to loose the ACK 
  
  \coordinate (pStartSend_#5) at ($(a) + (0,-0.5)-(0,#1)$); 
  \coordinate (pEndSend_#5) at  ($  (pStartSend_#5) + (0,-#3) $ ); 
  \coordinate (pStartReceive_#5) at ($ (pStartSend_#5) + (3.5,-2) $); 
  \coordinate (pEndReceive_#5) at ($  (pStartReceive_#5) + (0,-#3) $ ); 
  \coordinate (aStartSend_#5) at ($(b) +  (0,-0.5)-(0,#1)-(0,2)-(0,#3)  $); 
  \coordinate (aEndSend_#5) at ($ (aStartSend_#5)  + (0,-#4) $); 
  \coordinate (aStartReceive_#5) at ($ (aStartSend_#5) + (-3.5,-2)  $); 
  \coordinate (aEndReceive_#5) at ($ (aStartReceive_#5) + (0,-#4)  $);   

  % Packets: 
  \ifthenelse{\equal{#6}{X}}
  {
    % packet gets lost
    \coordinate (pStartLoss_#5) at ($ (pStartSend_#5) + (1.75,-1)  $); 
    \coordinate (pEndLoss_#5) at ($ (pStartLoss_#5) + (0,-#3)  $);

    \draw [fill=#2, semitransparent] (pStartSend_#5) --
    (pStartLoss_#5) decorate [decoration=zigzag] {-- (pEndLoss_#5)}
    -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5 lost!}; 
    
  }
  {
    % packet normally delivered
  \draw [fill=#2, semitransparent] (pStartSend_#5) -- (pStartReceive_#5) -- (pEndReceive_#5) -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5}; 
  \draw [->] (a) ++ (pStartSend_#5) -- (pStartReceive_#5); 
  \draw [->] (a) ++ (pEndSend_#5) -- (pEndReceive_#5); 

  % ACK:
    %ACK normally sent: 
  \draw [fill=#2, semitransparent] (aStartSend_#5) -- (aStartReceive_#5) -- (aEndReceive_#5) -- (aEndSend_#5); 


  \draw [->] (aStartSend_#5) -- (aStartReceive_#5); 
  \draw [->] (aEndSend_#5) -- (aEndReceive_#5); 
}
}

#+END_EXPORT 

**** test 


\begin{tikzpicture}
  \label{page:ll:alternating_bit_efficiency}

  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-8); 
  \draw (b) -- ++(0,-8);

  \coordinate (pStartSend) at (0, -0.5); 
  \coordinate (pEndSend) at (0, -3.5); 
  \coordinate (pStartReceive) at (3.5, -2.5); 
  \coordinate (pEndReceive) at (3.5, -5.5); 
  \coordinate (aStartSend) at (3.5, -5.5); 
  \coordinate (aEndSend) at (3.5, -6); 
  \coordinate (aStartReceive) at (0, -7.5); 
  \coordinate (aEndReceive) at (0, -8); 

  % \foreach \n in {pStartSend, pEndSend, pStartReceive, pEndReceive, aStartSend, aEndSend, aStartReceive, aEndReceive} { \node [red] at(\n) {X}; }
  

  \pplusa{0}{hpiyellow!30}{3}{0.5}{}{}
  
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pStartSend) to node [left] {$T_\mathrm{Packet}$ } (pEndSend); 

  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pEndSend) to node [left] {$d$ } (pEndReceive -| a); 
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pEndReceive -| a) to node [left] {$d$ } (aStartReceive); 
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (aStartReceive) to node [left] {$T_\mathrm{ACK}$ } (aEndReceive); 

%   \draw [decorate, decoration={brace,raise=3pt}] (aStartSend) to node [right] {$T_\mathrm{ACK}$ } (aEndSend); 


  \draw [decorate, decoration={brace,mirror,raise=40pt}] (pStartSend) to node [left=2cm, anchor=east] {total time} (aEndReceive); 

  
  \draw [dotted] (pEndReceive) -- (pEndReceive -| a); 
  
\end{tikzpicture}



