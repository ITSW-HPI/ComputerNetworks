\label{ch:link}

\begin{frame}[title={bg=Hauptgebaeude_Tag}]
 \maketitle 
\end{frame}

#+latex_header: \usepackage{ifthen}
#+latex_header: \usetikzlibrary{decorations.pathreplacing,decorations.pathmorphing,calc}


**** The story so far  

**** Plans for this chapter 

- Understand the main service provided by the link layer
  - Communication between two directly connected nodes
  - Framing of a physical bit stream into a structure of frames/packets
  - Error control: Detection and correction
  - Connection setup and release
  - Acknowledgement-based protocols
  - Flow control
- Some ideas about how to use extended finite state machines to specify communication protocols

\vskip-2.5em

*****                     
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


****** Learning outcomes 

*****                    
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



** Services                                                        :noexport:

**** The link layer’s service

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Link layer sits on top of the physical layer
  - Can thus use a bit stream transmission service
  - But: this service might have incorrect bits; only between neighbors


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: The link layer between network and physical layer, bridging the gap between packets and bits
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:layers}
#+NAME: fig:ll:layers
[[./standalone/ll.pdf]]



\pause 

*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:

- Expectations of the higher layer (networking layer)
  - Wants to use either a packet service or, sometimes, a bit stream service (rather unusual)
  - Does not really want to be bothered by errors
  - Does not really want to care about issues at the other end



**** Requirement options for link layer service

- Dependable service – yes/no
  - Has many facets
    - A delivered packet should have the same content as the transmitted packet
    - All packets have to be delivered eventually
    - Packets have to be delivered in order
  - Error control may be required 
    - Forward error control, acknowledgements
- Connection-oriented – yes/no 
  - Is a *shared context* to/with the peer entity required?
- Packet or bitstream abstraction
  - Usually in computer networks: packets 
  - What about a maximal packet length? 


**** Distinguish: Service versus implementation
- Note the difference between service and implementation
- One example: 
  - Connection-less & reliable service required by the network layer
  - Link layer decides to use connections internally as a means to help with error control
- What about other combinations? 


**** Basic link layer functions – Framing 
- How to turn a physical layer’s bit stream abstraction into individual, well demarcated frames
  - Usually necessary to provide error control – not obvious how to do that over a bit stream abstraction
  - Frames and packets are really the same thing, only a convention to
    talk about “frames'' in the link-layer context; we stick to ``packets''
\pause 
- In addition: Fragmentation & reassembly if network layer packets are longer than link layer packets

**** Basic link layer functions – Error control
- If desired by the network layer – usually is
- Usually built on top of frames 
- Error detection – are there incorrect bits?  
- Error correction – repair any mistakes that have happened? 
  - Forward error correction – invest effort before error happened; try to hide it from higher layers
  - Backward error correction – invest effort after error happened;
    try to repair it 

#+caption: Options for error control
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:errorcontrol}
#+NAME: fig:ll:errorcontrol
[[./standalone/ll.pdf]]



**** Basic link layer functions – Connection setup
- Connection: Shared state at sender and receiver 
- Connections useful for many purposes
  - Application context
  - Error control – several error control schemes rely on a *common context* between sender and receiver
- Question: how to *set up and terminate* a connection? What state information is required? 
  - Especially: if used on top of frames / packets? 
- Problem reappears later in the transport layer again, with some
  additional complications – treated there!

\pause 

***** Connection and circuit are very different!               :B_alertblock:
      :PROPERTIES:
      :BEAMER_env: alertblock
      :END:

Common confusion! 

**** Basic link layer functions – Flow control
- What happens with a fast sender and a slow receiver? 
- Sender will overrun buffers faster than the receiver can process the packets in that buffer
- Lots of transmission effort is wasted in this case
- Necessary to control the amount of frames a link layer sends per unit time, adapt to receiver’s capabilities
\pause 
- Problem reappears later in the transport layer again, with some
  additional complications – treated there!


** Framing                                                         :noexport:

**** Framing
- How to turn a bit stream into a sequence of frames?
  - More precisely: how does a receiver know when a frame starts and when it finishes? 

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
  \node [label=left:{From PHY to link layer: }]  (bits) {0010100111011010011010111011101010010111};
  \draw [<-] ($(bits.south)+(-3,0)$) -- ++(0,-1) node [below, align=center] {Start of\\ frame?};
  \draw [<-] ($(bits.south)+(+3,0)$) -- ++(0,-1) node [below, align=center] {Ende of\\ frame?};
\end{tikzpicture}
\caption{Finding start and end of frames/pacekts in a sequence of bits}
\label{fig:ll:framing}
\end{figure}



\pause 

Note: Physical layer might try to detect and deliver bits when the sender is not actually transmitting anything
- Receiver still tries to get any information from the physical medium


**** Framing: Basic options 

- Put a length field into the packet header
  - What happens if bit errors inside this field?
- Use special bytes/bit sequences to indicate start or end
  - What happens if *these* sequences should be transmitted?
  - Common technique: *stuffing*
    - At bit or byte level
    - Sender deliberately modifies transmitted data to ensure that
      sequences do not appear in payload 
- Violate agreed-upon values (*coding violations*)
  - E.g., incorrect modulation patterns
  - Very robust, but very inefficient 


*** Old framing slides                                             :noexport:
**** Framing by character counting
- Idea: Announce the number of bits (bytes, characters) in a frame to the receiver
- Put this information into the frame
- Has to be at the beginning of a frame – a frame header
- 

**** Basic technique: Put control data into a header               :noexport:
- Albeit ``character count'' is not a good framing technique, it illustrates an important technique: headers
- If sender has to communicate administrative or control data to receiver, it can be added to the payload, the actual packet content
- Usually at the start of the packet; sometimes at the end (a trailer)
- Receiver uses headers to learn about sender’s intention
- Same thing works for packet headers as well
**** Framing by flag bytes/byte stuffing
- Use dedicated flag bytes to demarcate start/stop of a frame
- What happens when the flag byte appears in the payload? 
- Escape it with a special control character – byte stuffing
- If that appears, escape it as well
**** Framing by flag bit patterns/bit stuffing
- Byte stuffing is closely tied to characters/bytes as fundamental unit – often not appropriate
- Use same idea, but stick with the bit stream abstraction of the physical layer
- Use a bit pattern instead of a flag byte – often, 01111110
- Actually, it IS a flag byte
- Use bit stuffing
- Whenever sender sends five 1’s in a row, it automatically adds a zero into the bit stream – except in the flag pattern
- Receiver throws away (``destuffs'') any 0 after five 1’s
**** Framing by coding violations
- Suppose the physical layer’s encoding rules ``bits $\leadsto$ signals'' still provide some options to play with
- Not all possible combinations that the physical layer can express are used to express bit patterns
- Example: Manchester encoding – only low/high and high/low is used
- When ``violating'' these encoding rules, data can be transmitted – e.g., the start and end of a frame
- Example: Manchester – use high/high or low/low 
- This drops the self-clocking feature of Manchester, but clock synchronization is sufficiently good to hold for a short while
- Powerful and simple scheme – used e.g. by Ethernet networks 
- But raises questions regarding bandwidth efficiency


** Error control                                                   :noexport:

**** Error control
- Two basic aspects:
  1. *Detect* the presence of errors (incorrectly received bits) in a frame 
  2. *Correct* errors in frames 
- Separate functions for error control
  - Detect, but do not correct
    - Typically, simply drop a frame; pretend that it never has arrived at the receiver
    - Higher layers can take corrective measures, if they so desire
  - Correct, but do not detect: Try to correct as many errors as possible, do not care if there are some remaining errors present
    - Only feasible if application is not (too much) bothered by errors
    - Example: voice applications can tolerate some degree of bits errors without loosing too much voice quality 
    - Functions for correction (very) inefficient if you only want to detect 
- Or combine both functions

**** Error control – redundancy 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Any form of error control requires redundancy in the frames
- Without redundancy
  - A frame of length $m$ can represent $2^m$ different frames
  - All of them are legal!


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   


#+caption: All possible frames are also legal frames, no redundancy
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:allframes}
#+NAME: fig:ll:allframes
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


- How could a receiver possibly decide that one legal frame is not the one that had originally been transmitted? 
- Not possible!
**** Error control – redundancy 

- Core idea: Declare some of the possible messages illegal!
  - Still need to be able to express $2^m$ legal frames
  - $\leadsto$ More than $2^m$ possible frames are required
  - $\leadsto$ More than $m$ bits are required in a frame  
  - Use frames with $n > m$ total length  
    - $r=n-m$ are the $redundant bits$ (often, as header or trailer)
- Having /more possible than legal frames/ allows receiver to detect
  illegal frames


#+caption: Distinguish between possible and legal frames
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:legalframes}
#+NAME: fig:ll:legalframes 
[[./standalone/econtrol.pdf]]



**** Simple redundancy example: Parity
- A simple rule to construct 1 redundant bit (i.e., $n=m+1$): Parity
  - Odd parity: Add one bit, choose its value such that the number of 1’s in the entire message is odd
  - Even parity: Add one bit, choose its value such that the number of 1’s in the entire message is even
- Example:
  - Original message without redundancy: ~01101011001~
  - Odd parity: ~01101011001~ *1* 
  - Even parity: ~01101011001~ *0*
**** How do illegal messages help with detecting bit errors?
- Transmitter only sends legal frame
- Physical medium/receiver might corrupt some bits
- *Hope*: A legal frame is only corrupted into an illegal frame
  - But one legal frame is never turned into another legal frame
- Necessary to realize this hope: 
  - Physical medium only alters up to a certain number of bits (by assumption) – say, $k$ bits per frame
    - *This is only an assumption!*
    - Alternative formulation: More than $k$ bit alternations have negligible probability 
    - How does it relate to the BER or the SNR? 
  - Legal messages are sufficiently different so that it is not possible to change one legal frame into another by altering at most k bits
**** Altering frames by changing bits
- Suppose the following frames are the only legal bit patterns: 0000, 0011, 1100, 1111
- Four-bit sequences form a hypercube when connecting sequences that
  only differ in a single position 


#+caption: Four-bit sequences arranged in a hypercube; neighbors are sequences that differ in at most a single bit position; blue circles show legal frame, orange circles differ from legal frames by one bit position, red circles differ in two bit positions (inspired by [[https://texample.net/tikz/examples/gray-code-in-4-cube/][Gray codes in TikZ]])
#+attr_latex: :width 0.95\textwidth :height 0.4\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:altering_frames}
#+NAME: fig:ll:altering_frames
[[./standalone/econtrol.pdf]]



*** Hamming distance 
**** Distance between frames
- In previous example: Two bit changes necessary to go from one legal frame to another
- Formally: *Hamming distance of two frames*
- Let $x=x_11,\dots, x_n$ and $y=y_1,…, y_n$ be two frames
- $d(x,y)$ = number of ``1'' bits in $x\, \mathrm{XOR}\, y$ 
  - Or: the number of bit positions where x and y are different


#+caption: Example for definition of Hamming distance 
#+name: tag:ll:hamming_definition 
#+ATTR_LATEX: :align rcl
| $x$                | = | 0011010111 |
| $y$                | = | 0110100101 |
|--------------------+---+------------|
| $x \,\mathrm{XOR}\, y$ | = | 0101110010 |
| $d(x,y)$           | = |          5 |




**** Hamming distance of a set of frames
- The Hamming distance of a set of frames S: 

\[ d(S) =  \min _{x, y \in S, x \not = y} d(x,y)
\label{eq:hamming_distance}
\]

- The smallest distance between any two frames in the set

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


#+caption: Example for Hamming distance = 2
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:simple_hamming:1}
#+NAME: fig:ll:simple_hamming:1
[[./standalone/econtrol.pdf]]



***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Example for Hamming distance = 1
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:simple_hamming:2}
#+NAME: fig:ll:simple_hamming:2
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


 

** Forward error correction

*** Basic correction 
**** Hamming distance and error detection/correction
- What happens if $d(S) = 0$?
  - This is nonsense, by definition
- What happens if $d(S) = 1$?

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}; }
\end{center}
#+end_export 

- There exist $x,y \in S$ such that $d(x,y) = 1$; no other pair is closer
- A single bit error converts from one legal frame $x$ to another legal frame $y$
- Cannot detect or correct anything
**** Hamming distance and detection/correction
- What happens if $d(S) = 2$?
  - There exist $x,y \in S$ such that $d(x,y) = 2$; no other pair is closer

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} 
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$u$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}
; }
\end{center}
#+end_export 

- In particular: any $u$ with $d(x,u) = 1$ is illegal, 
- I.e., errors that modify a single bit always lead to an illegal frame
- $\leadsto$ Error can be detected!
- Generalizes to all legal frames, because Hamming distance describes the ``critical cases''
- But not corrected – upon receiving u, no way to decide whether x or
  y had been sent (symmetry!)


**** Hamming distance and detection/correction
- What happens if $d(S) = 3$?
  - There exist $x,y \in S$ such that $d(x,y) = 3$; no other pair is closer
  - Every $u$ with $d(x,u)=1$ is illegal AND $d(u,s) > 1$! 

#+begin_export latex
\begin{center}
\tikz{\draw (0,0) node[fill=white] {$x$} 
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$u$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$v$}
to node [above, align=center] {1 bit \\difference} ++(3,0) node[fill=white] {$y$}
; }
\end{center}
#+end_export 


- Hence: the receipt of u could have the following causes:
  - Originally, $x$ had been sent, but 1 bit error occurred
  - Originally, $y$ had been sent, but 2 bit errors occurred
  - (Originally, some other frame had been sent, but at least 2 bit errors occurred)
- Assuming that fewer errors have happened, a received frame $u$ *is presumed* to have been caused by sending $x$!
  - Hence, the error has been ``corrected'' – hopefully, correctly!

**** Generalization – Required Hamming distances
- The examples above can be generalized
- To *detect* $d$ bit errors, a Hamming distance of $d+1$ in the set of legal frames is required
  - So that it is not possible to re-write a legal frame into another one using at most d bits
- To *correct* $d$ bit errors, a Hamming distance of $2d+1$ in the set of legal frames is required
  - So that all illegal frames at most $d$ bits away from legal frame are more than $d$ bits away from any other legal frame 
**** Frame sets – code books, codes

Some terminology: 
- The set of legal frames $S \in {0,1}^n$ is also called a *code book* or simply a *code*
- The *rate* $R_S$ of a code $S$ is defined as:
  \[  R_S = \frac{\log |S|}{n} \] 
  - Rate characterizes the efficiency
- The *distance* $\delta_S$  of a code $S$ is defined as: 
  \[ \delta_S  = \frac{d(S)}{n}\]
  - Distance characterizes error correction/detection capabilities

\pause 
A good code should have large distance and large rate – but arbitrary combinations are not possible
**** How to construct error correcting codes
- Constructing good codes (e.g., highest rate at given error correction needs) is difficult
- Simple example: use several parity bits
  - Distribute the parity bits over the entire codeword to protect against burst errors 
- Two main classes of actual codes
  - Block codes 
  - Convolutional codes

- Fancy techniques 
  - Turbo codes: generalization/successors to convolutional codes, almost capacity-achieving 
  - Low-Density Parity Check (LDPC): almost capacity-achieving 

**** Block codes: Bounds 
- Block codes operate on blocks of $k$ payload bits, outputting blocks of length $n$ by adding redundancy $r=n-k$
- Defining property: Output of $n bits *only* depends on these very $k$ input bits
- Each coded bit: XOR of several payload bits
  - Which payload bits get XOR'ed into which output bit defines the
    specific code as such 

#+caption: Block code turning blocks of $k$ payload bits into blocks of $n$ coded bits using XOR operations
#+attr_latex: :width 0.95\textwidth :height 0.3\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:block_code}
#+NAME: fig:ll:block_code
[[./standalone/econtrol.pdf]]




**** Bounds for block codes 
- Property: Binary block codes can correct up to t errors in a
  codeword of length n with k user bits only if (Varshamov-Gilbert
  bound):

\[ 
2^{n-k} \geq \sum _{i=0} ^t {n \choose i} 
\label{eq:varshamov:gilbert}
\]


-  But code for arbitrary  $(n, k, t)$ combination  does not necessarily exist



*** Detour: Polynomials                                            :noexport:


**** How to deal with error control mathematically 
- We need rules how to compute redundancy bits and how to interpret received sequence of (possibly erroneous) bits 
- For both error correction and error detection 
- Should be: 
- Efficiently implementable in hardware
- Provable properties! 
- Basic operation based on polynomial arithmetic
- Bit string is interpreted as representing a polynomial
- Coefficients 0 and 1 are possible, interpreted modulo 2
- As are groups of bits
- Interpreted than as modulo 2^k 
  - 
**** Modulo 2 arithmetic 
- With 0 and 1 as the only possible numbers (bits!), normal arithmetic is not applicable
- Instead: look at modulo 2 arithmetic
- Rules: 
- Addition modulo 2 Subtraction modulo 2Multiplication modulo 2
- Example: 0110111011 
-                 ©  1101010110 = 1011101101
**** Matrix multiplication 
- With addition and multiplication in place, we can define matrix multiplication quite easily 
- 
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 38
**** Modulo 2 division
- Division of two numbers is done just like normal division
- 1101010110 / 1001 = 1100110  1001
-       1000
-       1001
-         001101
-             1001
-               1001
-               1001
-                   
**** Modulo 2 division with remainder
- After division, a remainder may result 
- 1101010101 / 1001 = 1100110  remainder 11  1001
-       1000
-       1001
-         001101
-             1001
-               1000
-               1001
-                 0011
**** Polynomials over modulo 2 arithmetic
- Define polynomials over modulo 2 arithmetic
- p(x) =  an ¢ xn © … © a1 x1 © a0
- Coefficients and x 2 {0,1}
- Addition, subtraction, multiplication and division of polynomials is defined in the usual way!
- Using modulo 2 arithmetic, of course 
**** Bit strings and polynomials modulo 2
- Idea: Conceive of a string of bits as a representation of the coefficients of a polynomial
- Bit string: bnbn-1…b1b0
- Polynomial: bn¢xn © … © b1¢x1 © b0
- A bit string of (n+1) bits corresponds to a degree n polynomial!
- Operations on bit strings correspond to operations on polynomials and vice versa
- Example: ``Add k zeros'' $ ``multiply by xk''
- This isomorphism allows us to divide bit strings!
- 
**** Generalization: Groups of bits 
- Instead of looking at polynomials over just 0/1 (the GF(2) Galois Field), we can also group bits together 
- Popular choice: group 8 bits together 
- Galois Field GF(2^8)
- Also called Rijndael‘s finite field 
- Addition, subtraction work similarly, multiplication of polynomials becomes a bit more complicated 
- Practically, often more suitable than working on bit sequences 
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 43


*** Matrixes 


**** Notation for block codes: one output bit  

- Output bit of a block code: XOR of several payload bits
  - E.g.: $o = x_1 \,\mathrm{XOR}\, x_5  \,\mathrm{XOR}\, x_7 \,\mathrm{XOR}\, x8$ 
\pause 
- Equivalent: Sum of these payload bits, modulo 2 
  - E.g., $o = (x_1 + _x5 + x_7 + x_8) \, \mathrm{MOD}\, 2$
\pause 
- Which payload bits: multiply by zero or one 
  - E.g., $o = (0\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  0 \cdot x4 + 1 \cdot _x5 + 0 \cdot x_6 + 1 \cdot  x_7 + 1\cdot  x_8) \, \mathrm{MOD}\, 2$

**** Notation for block codes: several  output bits 

E.g.: 

- $o_0 = (0\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  0  \cdot x4 + 1 \cdot _x5 + 0 \cdot x_6 + 1 \cdot  x_7 + 1 \cdot x_8) \, \mathrm{MOD}\, 2$
- $o_1 = (1\cdot x_0 + 1\cdot  x_1 + 0 \cdot x_2 + 0 \cdot x_3 +  1  \cdot x4 +0 \cdot _x5 + 1 \cdot x_6 + 1 \cdot  x_7 + 0 \cdot x_8) \, \mathrm{MOD}\, 2$
- $o_2 = (0\cdot x_0 + 0\cdot  x_1 + 1 \cdot x_2 + 0 \cdot x_3 +  1  \cdot x4 + 1 \cdot _x5 + 0 \cdot x_6 + 0 \cdot  x_7 + 0 \cdot x_8) \, \mathrm{MOD}\, 2$
- \dots 
\pause 

That can be written more compactly as a matrix mutliplication 

**** Notation for block codes: matrix representation 


\[
(x_0 x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9)  \cdot 
\begin{pmatrix}
  0 & 1 & 0 & \dots \\
  1 & 1 & 0 & \dots \\
  0 & 0 & 1 & \dots \\
  0 & 0 & 0 & \dots \\
  0 & 1 & 1 & \dots \\
  1 & 0 & 1 & \dots \\
  0 & 1 & 0 & \dots \\
  1 & 1 & 0 & \dots \\
  1 & 0 & 0 & \dots \\
\end{pmatrix} = ( o_0 o_1 o_2 \dots o_n)
\label{eq:block_matrix}
\]


**** Codes as matrix operations: nonsystematic code 

- What is a *suitable* matrix to compute coded bits? 
- In general: a *nonsystematic code* 
  - Using a *generator matrix*
- Given payload $p$, find codeword c using generator $G$ as $c = pG$ 
- Examples: 

\[
\underbrace{( 1 0 0 1)}_{\mathrm{Payload}} \cdot
\underbrace{\begin{pmatrix}
0 & 1&1 &0 &1 &1 &0 \\
1 & 1&0 &1 &1 &0 &0 \\ 
1 & 0& 1& 1& 0& 1& 1  \\
0 &0 &0 &1 &0 &0 &0  \\
\end{pmatrix}}_{\mathrm{Generator }\,G} = 
\underbrace{(0 0 1 1 0 0 1)}_{\mathrm{Codeword}}
\]



**** Codes as matrix operations: Systematic codes 
- Let’s look at generator matrix with a particular structure 
  - Identity matrix $I_k$, append matrix for $A$ parity bits 
  - For $k$ payloads, and $(n-k)$ redundancy bits, $A$ is a $(k, n-k)$
    matrix 
  - $ G = (I_k | A)$

- Example 

\[
\underbrace{( 1 0 0 1)}_{\mathrm{Payload}} \cdot
\underbrace{\begin{pmatrix}
1 & 0& 0 &0 & | & 1 &1 &0 \\
0 & 1&0 &0 & | & 1 &0 &0 \\ 
0 & 0& 1& 0 & | & 0& 1& 1  \\
0 &0 &0 &1  & | & 0 &0 &0  \\
\end{pmatrix}}_{\mathrm{Generator }\,G} = 
\underbrace{(1 0 0 1 |  0 0 1)}_{\mathrm{Codeword}}
\]



**** Decoding of systematic codes? 
- Encoding is easy – how about decoding? 
  - Getting back the original payload from the (possibly erroneous) received bits 
- First step: Use a *parity-check matrix* $H$ 
  - For $k$ payloads and $n-k$ redundancy bits, $H$ is an $(n-k, n)$ matrix 
- For a *valid* codeword $c$, it must hold:
  \[ H c^T = 0]
  - Hence:  if result <> 0, codeword is not valid
- One way to check for errors (but not a particularly efficient one, if error checking is all you want to do) 



**** Relationship of generator and parity check matrix? 
- Generator matrix and parity check matrix are related:
  - Recall: A is a (k, n-k) matrix 
  - \[  G = (I_k | A)\] 
  - Then define: \[ H = (-A^T | I_{n-k})  \] 
\pause 
- Why use this to show: 
  \[  G H^T = 0   \]
  - And continue to show that this is indeed parity-check matrix! 
- One way to check for errors (but not a particularly efficient one, if error checking is all you want to do) 
  


**** Example: Hamming (7,4) code                                   :noexport:



**** Decoding: Maximum likelihood decoding 
- Suppose we received an invalid codeword $c$ 
  - We want to map it to original payload 
  - Under stochastic assumptions: errors happened randomly 
- What is then the ``right'' answer, the ``right'' payload to identify? 
- Simple approach:
  - For each payload, there is a likelihood that we received that invalid $c$ 
    - Under stochastic assumptions how errors happen
  - We decide for that payload that maximizes this likelihood (maximum likelihood decoding) 
  - Under independent bit errors: the one with the smallest Hamming distance! 
\pause 
- Details: highly depends on specific code family 

**** Maximum likelihood decoding: How?                             :noexport:
- Trivial approach: Search through all codewords around the received (invalid) codeword c 
- Akin to an expanding ring search: Hamming distance 1, 2, … 
- Simple, but sloooow 
- Efficient? 
- Syndrome decoding 
- Iterative algorithms, often amenable to hardware implementations
- For details, check lecture Blömer Codes & Crypto 
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 51


*** BCH 
**** Block code examples 

- Bose Chaudhuri Hocquenghem (BCH) codes – based on polynomials over finite fields 
- Reed Solomon codes (special case of non-binary BCH codes)



**** Example: BCH codes 
- Family of binary block codes 
  - Binary: polynomials with coefficients 0 and 1 (over GF(2))
- BCH: Bose & Chaudhuri [[cite:&Bose1960-br]], Hocquenghem \cite{hocquenghem59:_codes}
- Properties: For any integer $m > 2$ and $t < 2m-1$, there exist a BCH code with 
  - Block length: $n = 2m -1 $
  - Number of parity-check digits: $n–k \leq mt$ 
    - With tight bound for small $t$ 
  - Minimum Hamming distance: $d >= 2t + 1$
    - I.e., can correct up to $t$ errors 
  - (k: number of payload bits)
- Interpretation: Bound on how many payload bits, given desired error correction capability 


**** BCH parameters

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- Issue: no simple formulas to compute $n-k$
- Example values for n, k, t  

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   




#+caption: Example combinations for BCH codes with codeword length 127
#+Name: tab:ll:bch 
| Codeword length $n$ | Payload $k$ | Correctable errors $t$ |
|---------------------+-------------+------------------------|
|                 127 |         120 |                      1 |
|                 127 |         113 |                      2 |
|                 127 |         106 |                      3 |
|                 127 |          99 |                      4 |
|                 127 |          92 |                      5 |
|                 127 |          85 |                      6 |
|                 127 |          78 |                      7 |
|                 127 |          71 |                      9 |
|                 127 |          64 |                     10 |
|                 127 |          57 |                     11 |
|                 127 |          50 |                     13 |
|                 127 |          43 |                     14 |
|                 127 |          36 |                     15 |
|                 127 |          29 |                     21 |
|                 127 |          22 |                     23 |
|                 127 |          15 |                     27 |
|                 127 |           8 |                     31 |
|                     |             |                        |




**** Example: Reed-Solomon codes 
- Generalization of BCH codes to non-binary symbols 

- Applications: 
  - Data storage – RAID, CDs, DVDs
  - Some simple data transmission techniques 

**** Block error rate for BCH codes

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:

- Block is considered in error if any bit errors remain after correction 
- Example: codewords 127 bit, varying number of correctable bit errors (``c'' in legend)




***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   


#+caption: Packet error rate achieved by BCH codes for varying number of correctable errors $t$ as function of signal-to-noise ratio
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:per_over_snr}
#+NAME: fig:ll:per_over_snr
[[./standalone/bch.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Coding gain 

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


Note: 
- the roughly parallel curves, once SNR gets ``good enough''
- double logarithmic axes 

\pause 
Gives rise to notion of *coding gain*
- The factor of SNR needed to get the same PER from two different
  codes 



***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   

#+caption: Coding gain: Factor between two SNR needed by two dfiferent FEC schemes to obtain comparable PER
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:per_over_snr:with_coding_gain}
#+NAME: fig:ll:per_over_snr:with_coding_gain
[[./standalone/bch.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:


*** Convolutional codes 
**** Convolutional codes

\vskip-2.5em

***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:



- Block codes: *one* block of payload bits determines *one* block of
  coded bits 
  - There is no history; previous bits do not matter
- Convolutional codes: Take into account a couple of previous payload
  blocks as well
  - Otherwise, quite similar
  - Payloads in blocks of $k$ bits, $n$ output bits determined from
    the last $K\cdot k$ bits
    - $K$: constraint length 
  


***** 
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   



#+caption: Structure of convolutional code for payload block length $k$, output block length $n$ , and constraint length $K$
#+attr_latex: :width 0.95\textwidth :height 0.6\textheight :options keepaspectratio,page=\getpagerefnumber{page:ll:convolutional_code}
#+NAME: fig:ll:convolutional_code
[[./standalone/econtrol.pdf]]



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



**** Decoding convolutional codes – Viterbi algorithm
- Encoding convolutional codes is trivial
  - simple shift register (just like block codes)
- Decoding? 
- Popular: *Viterbi algorithm* [[cite:&Viterbi1967-gv]]
  - *Dynamic programming* technique
  - Idea: hidden (for the receiver) sequence of states (= sent bits), receiver observes sequence of events (= received bits)
  - Viterbi algorithm determines the most likely sequence of states that has caused the observed sets of events 
  - *Maximum likelihood property* makes this algorithm powerful
  - Can be nicely implemented in hardware, but costly (*large* chip area!)


**** Convolutional codes: Properties 
- Still popular codes in wireless transmission 
  - Relatively close to Shannon bound/channel capacity!
  - Allow plenty of additional tricks, e.g., puncturing 
- Typical examples: 
  - Turbo codes: Two convolutional codes nested within each other, informing each other over error patterns
    - Used in UMTS, LTE, \dots 
- Low-density parity check codes
  - Tend to outperform Turbo codes at higher code rates
  - Used e.g. in DVB-S2, 10GBast-T Ethernet, \dots optional in 802.11n, 11ac



**** An additional trick: Interleaving                             :noexport:
- How to deal with burst errors? Spanning multiple code blocks?  
- WS 19/20, v 1.7
- Computer Networks - Link layer
- 60

** Error detection                                                 :noexport:

*** CRC 
**** How to construct error detecting codes – CRC 
- Efficient error detection: Cyclic Redundancy Check  (CRC)
- Gives rules how to compute redundancy bits and how to decide whether a received bit pattern is correct
- Very high detection probability with few redundancy bits
- Efficiently implementable in hardware
- Basic operation based on polynomial arithmetic
- Bit string is interpreted as representing a polynomial
- Coefficients 0 and 1 are possible, interpreted modulo 2
- 
**** Use polynomials to compute redundancy bits – CRC 
- Define a generator polynomial G(x) of degree g
- Known to both sender and receiver
- We will use g redundancy bits in the end
- Given: message/frame M, represented by polynomial M(x)
- Transmitter
- Compute remainder r(x) of division xgM(x) / G(x)
- Note: Remainder after division is of degree < g, fitting into g bits!
- Transmit T(x) = xgM(x) – r(x) 
- Note: xgM(x) – r(x) is divisible without remainder by G(x)
- Receiver
- Receive m(x)
- Compute remainder of division of m(x) by G(x)
**** CRC transmission and reception
- What happens in the channel after transmitting T(x)?
- No errors: T(x) arrives correctly at the receiver
- Bit errors occur: T(x) is modified by flipping some bits 
- Equivalent to modifying some coefficients of the polynomial
- Equivalent to adding an error polynomial E(x)
- At the receiver, T(x) © E(x) arrives
- At the receiver
- Receive m(x)
- Compute remainder of division of m(x) by G(x)
- No errors: m(x) = T(x). Remainder is zero!
- Bit errors: m(x)/G(x) = (T(x) © E(x))/ G(x) = T(x)/G(x) © E(x)/G(x)
**** CRC – Overview 
**** Choice of G(x) determines CRC properties
- When is remainder of E(x) / G(x) <> 0?
- If G(x) divides E(x) without remainder, an error slips through!
- Single bit error: E(x) = xi for error at position i
- G(x) needs two or more terms to ensure that E(x) is not a multiple of it
- Two bit errors: E(x) = xi © xj = xj (xi-j +1) for some i>j
- x must not divide G(x)
- G(x) must not divide (xk + 1) for all k up to, e.g., maximum frame length
- Odd number of errors: E(x) has an odd number of terms
- E(x) will NOT have (x+1) as a factor
- Make (x+1) a factor of G(x) so that it cannot divide E(x)
- Using r check bits, all burst errors of length <= r can be detected 
**** Practical CRC 
- Practically used generator polynomial (IEEE 802):
- x32 © x23 © x16 © x12 © x11 © x10 © x8 © x7 © x5 © x4 © x2 © x © 1
- In practice, residual errors after CRC check are ignored
- But they may still happen!
- In particular, when bit errors are not independent, but bursty
- Implementation in hardware: shift register circuit
- Negligible overhead in hardware, time, energy 
- 


** Backward error correction                                       :noexport:





**** How to handle detected errors? 
- Suppose the CRC function detects an error 
- Clearly, the received frame cannot be delivered to higher layers/application
-  $\leadsto$ Have to repair the error somehow 
- Backward error recovery
- Here: frame has to be retransmitted
- How to tell the sender? 
**** A simple, simplex, acknowledgement-based protocol
- Acknowledge to sender the receipt of a packet
- Sender waits for acknowledgement for a certain time
- If not received in time, packet is retransmitted
- First solution attempt: 
- SenderReceiver
**** Protocol analysis
- This protocol is nice and simple, but flawed in multiple ways
- What happens when the higher layer sends packets faster than the acknowledgements come in (and when one is missing?)
- What happens if acknowledgements are lost?
-  $\leadsto$ Need some fixes for the protocol here…
**** Acknowledgement-based protocol, second trial
- Cure one problem: Concentrate on one packet, only accept the next packet from higher layer when previous one has been fully processed
- First solution attempt: 
- SenderReceiver
- 
**** Does second version work correctly?
- It holds back the transmitter until packets are processed
- It implements flow control!
- Does it ensure that all packets arrive, in correct order? 
**** Does second version work correctly? 
- Simple cases seem ok
- What if an acknowledgement is lost? 
**** Problem of second version
- Sender cannot distinguish between a lost packet and a lost acknowledgement $\leadsto$ has to re-send the packet
- Receiver cannot distinguish between a new packet and a redundant copy of an old packet
-  $\leadsto$ Additional information is needed 
- Put a sequence number in each packet, telling the receiver which packet it is
- Sequence numbers as header information in each packet 
- Simplest sequence number: a 0 or 1 !
- Needed in packet & acknowledgement 
- In Ack, convention: send the sequence number of the last correctly received packet back
- Also possible: send sequence number of next expected packet 
**** Acknowledgements & sequence numbers – 3rd version
**** Assessment of 3rd version – Alternating bit protocol
- This 3rd version is a correct implementation of a reliable protocol over an error-prone channel
- Name: Alternating bit protocol
- Class of protocols where sender waits for a positive confirmation: Automatic Repeat reQuest (ARQ) protocols
- It also implements a simple form of flow control
- Note the dual task of the acknowledgement packet
- It confirms to the sender that the receiver has obtained a certain packet
- It is also the permit to send the next packet, stating that the receiver has the capacity to handle it
- These two functions can be and are separate in other protocols!
**** Alternating bit protocol – Efficiency  
- Efficiency \rho depends on circumstances
- Defined as the ratio of time during which the sender sends new information (assuming an error-free channel in the simplest case; error-considerations make efficiency discussions difficult)
-  \rho = Tpacket  / (Tpacket + d + Tack + d) 
- Efficiency of simple alternating bit protocol is low when delay is large compared to data rate
- Recall bandwidth-delay product!
**** Improving efficiency – have more ``outstanding'' packets
- Inefficiency of alternating bit in large bandwidth-delay situations is owing to not exploiting ``space'' between packet and acknowledgement 
- Always sending packets results in high efficiency
- More packets are ``outstanding'' = sent, but not yet acknowledged
- ``pipelining'' of packets
- But not feasible with a single bit as sequence number
-  $\leadsto$ Need larger sequence number space! 
- It also needs – ideally – some full-duplex support
- How to live without full-duplex?
**** Sliding windows to handle multiple outstanding packets
- Introduce a larger sequence number space
- Say, n bits or 2n sequence numbers 
- Not all of them may be allowed to be used simultaneously
- Recall alternating bit case: 2 sequence numbers, but only 1 may be ``in transit''
- Use sliding windows at both sender and receiver to handle these numbers
- Sender: sending window – set of sequence numbers it is allowed to send at given time or that are currently ``in flight'' (depends on protocol) 
- Receiver: receiving window – set of sequence numbers it is allowed to accept at given time
- May be fixed in size or adapt dynamically over time
- Window size corresponds to flow control 
**** Sliding window – simple example
- A simple sliding window example for n=3, window size fixed to 1
- Sender here represents the currently unacknowledged sequence numbers (``in flight'') 
**** Transmission errors and receiver window size
- Assumption: 
- Link layer should deliver all frames correctly and in sequence
- Sender is pipelining packets to increase efficiency
- What happens if packets are lost (discarded by CRC)? 
- With receiver window size 1, all following packets are discarded as well!
**** Go-back-N
- With receiver window size 1, all frames following a lost frame cannot be handled by receiver
- They are out of sequence
- They cannot be acknowledged, only ACKs for the last correctly received packet can be sent
- Sender will timeout eventually
- Since all frames sent in the meantime have been discarded, they have to be repeated
-  $\leadsto$ Go-back N (frames)! 
- Assessment
- Quite wasteful of transmission resources
- But saves overhead at the receiver 
**** Selective repeat
- Suppose we invest a bit into a receiver that can buffer packets intermittently if some packets are missing
- Corresponds to receiver window larger than 1
- Resulting behavior:
- Receiver explicitly informs sender about missing packets using Negative Acknowledgements
- Sender selectively repeats the missing frames 
- Once missing frames arrive, they are all passed to the network layer
**** Duplex operation and piggybacking 
- So far, simplex operation at the (upper) service interface was assumed
- The receiver only sent back acknowledgements, possibly using duplex operation of the lower layer service
- What happens when the upper service interface should support full-duplex operation?
- One option: Use two separate channels for each direction – wasteful
- Better: Interleave acknowledgement and data frames in a given direction
- Best (and usual): Put the acknowledgement information for direction A! B into the data frames for B $\leadsto$ A 
- As part of B’s header – piggyback it 
**** Combine FEC and ARQ?
- If ARQ used, does FEC still make sense? 
- Yes, depending on the error situation
- Trade-off:
- With stronger FEC, packet error rate reduces, fewer retransmissions
- But also fewer payload bits per fixed-size codeword 
- Recall setup from earlier slide: 
- Block is considered in error if any bit errors remain after correction 
- Example: codewords 127 bit, varying number of correctable bit errors (``c'' in legend)
- Simulated 1500 blocks, at varying SNR, AWGN channel, BPSK modulation 
**** Combine FEC and ARQ? – Performance 
- Now add unlimited number of retransmissions, compute expected number of correctly delivered bits per packet time


** Conclusion 

**** Conclusion  

Lorem ipsum 


**** Conclusion
- Most problems in the link layer are due to errors
- Errors in synchronization require non-trivial framing functions
- Errors in transmission require mechanisms to correct them so as to hide from higher layers
- Or to detect them and repair them afterwards
- Flow control is often tightly integrated with error control in practical protocols
- But it IS a separate function and can be realized separately as well
- Connection setup/teardown still has to be treated
- Necessary to initialize a joint context for sender and receiver


** ARQ tests                                                       :noexport:



#+BEGIN_EXPORT latex

\newcommand{\pplusa}[6]{%
  % #1: offset, #2: fill color #3: packet length #4: ACK length, #5 label
  % #6: X to loose the ACK 
  
  \coordinate (pStartSend_#5) at ($(a) + (0,-0.5)-(0,#1)$); 
  \coordinate (pEndSend_#5) at  ($  (pStartSend_#5) + (0,-#3) $ ); 
  \coordinate (pStartReceive_#5) at ($ (pStartSend_#5) + (3.5,-2) $); 
  \coordinate (pEndReceive_#5) at ($  (pStartReceive_#5) + (0,-#3) $ ); 
  \coordinate (aStartSend_#5) at ($(b) +  (0,-0.5)-(0,#1)-(0,2)-(0,#3)  $); 
  \coordinate (aEndSend_#5) at ($ (aStartSend_#5)  + (0,-#4) $); 
  \coordinate (aStartReceive_#5) at ($ (aStartSend_#5) + (-3.5,-2)  $); 
  \coordinate (aEndReceive_#5) at ($ (aStartReceive_#5) + (0,-#4)  $);   

  % Packets: 
  \ifthenelse{\equal{#6}{X}}
  {
    % packet gets lost
    \coordinate (pStartLoss_#5) at ($ (pStartSend_#5) + (1.75,-1)  $); 
    \coordinate (pEndLoss_#5) at ($ (pStartLoss_#5) + (0,-#3)  $);

    \draw [fill=#2, semitransparent] (pStartSend_#5) --
    (pStartLoss_#5) decorate [decoration=zigzag] {-- (pEndLoss_#5)}
    -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5 lost!}; 
    
  }
  {
    % packet normally delivered
  \draw [fill=#2, semitransparent] (pStartSend_#5) -- (pStartReceive_#5) -- (pEndReceive_#5) -- (pEndSend_#5);
  \node at ($(1.75,-0.5) - (0,#1) - (0,0.5*#3) -(0, 1)$) {P\,#5}; 
  \draw [->] (a) ++ (pStartSend_#5) -- (pStartReceive_#5); 
  \draw [->] (a) ++ (pEndSend_#5) -- (pEndReceive_#5); 

  % ACK:
    %ACK normally sent: 
  \draw [fill=#2, semitransparent] (aStartSend_#5) -- (aStartReceive_#5) -- (aEndReceive_#5) -- (aEndSend_#5); 


  \draw [->] (aStartSend_#5) -- (aStartReceive_#5); 
  \draw [->] (aEndSend_#5) -- (aEndReceive_#5); 
}
}

#+END_EXPORT 

**** test 


\begin{tikzpicture}
  \label{page:ll:alternating_bit_efficiency}

  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-8); 
  \draw (b) -- ++(0,-8);

  \coordinate (pStartSend) at (0, -0.5); 
  \coordinate (pEndSend) at (0, -3.5); 
  \coordinate (pStartReceive) at (3.5, -2.5); 
  \coordinate (pEndReceive) at (3.5, -5.5); 
  \coordinate (aStartSend) at (3.5, -5.5); 
  \coordinate (aEndSend) at (3.5, -6); 
  \coordinate (aStartReceive) at (0, -7.5); 
  \coordinate (aEndReceive) at (0, -8); 

  % \foreach \n in {pStartSend, pEndSend, pStartReceive, pEndReceive, aStartSend, aEndSend, aStartReceive, aEndReceive} { \node [red] at(\n) {X}; }
  

  \pplusa{0}{hpiyellow!30}{3}{0.5}{}{}
  
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pStartSend) to node [left] {$T_\mathrm{Packet}$ } (pEndSend); 

  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pEndSend) to node [left] {$d$ } (pEndReceive -| a); 
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (pEndReceive -| a) to node [left] {$d$ } (aStartReceive); 
  \draw [decorate, decoration={brace,mirror,raise=3pt}] (aStartReceive) to node [left] {$T_\mathrm{ACK}$ } (aEndReceive); 

%   \draw [decorate, decoration={brace,raise=3pt}] (aStartSend) to node [right] {$T_\mathrm{ACK}$ } (aEndSend); 


  \draw [decorate, decoration={brace,mirror,raise=40pt}] (pStartSend) to node [left=2cm, anchor=east] {total time} (aEndReceive); 

  
  \draw [dotted] (pEndReceive) -- (pEndReceive -| a); 
  
\end{tikzpicture}


**** Go-Back N: Example trace 

\begin{figure}[h]
  \centering
  \maxsizebox{!}{0.6\textheight}{
  \begin{tikzpicture}
  \label{page:ll:gobackn}
  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-25); 
  \draw (b) -- ++(0,-25);

  \pplusa{0}{hpiorange!30}{2}{0.25}{1}{}
  \node [left=0.1 of pStartSend_1, align=right] {Send window=3, reduce to 2};
  \node [right=0.1 of pEndReceive_1, align=left] {Expected P1, got P1, deliver}; 

\onslide<2->
  \pplusa{2.5}{hpiblue!30}{2}{0.25}{2}{}
  \node [left=0.1 of pStartSend_2, align=right] {Send window=2, reduce to 1};
  \node [right=0.1 of pEndReceive_2, align=left] {Expected P2, got P2, deliver}; 

\onslide<3->
  \pplusa{5}{hpiyellow!30}{2}{0.25}{3}{X}
  \node [left=0.1 of pStartSend_3, align=right] {Send window=1, reduce to 0};

\onslide<4->
  \node [left=0.1 of aEndReceive_1, align=right] {Increase send window to 1};


\onslide<5->
  \pplusa{7.5}{hpired!30}{2}{0.25}{4}{}
  \node [left=0.1 of pStartSend_4, align=right] {Send window=1, reduce to 0};

\onslide<6->
  \node [left=0.1 of aEndReceive_2, align=right] {Increase send window to 1};


\onslide<7->
  \pplusa{10}{hpiorange!80}{2}{0.25}{5}{}
  \node [left=0.1 of pStartSend_5, align=right] {Send window=1, reduce to 0};

\onslide<8->
  \node [right=0.1 of pEndReceive_4, align=left] {Expected P3, got P4, discard, CumAck=2}; 


\onslide<9->
  \node [left=0.1 of pEndSend_5, align=right] {Timeout for ACK 3!};

\onslide<10->
  \pplusa{12.5}{hpiblue!80}{2}{0.25}{3b}{}
  \node [left=0.1 of pStartSend_3b, align=right] {Retransmit 3, send window stays at 0};

\onslide<11->
  \node [right=0.1 of pEndReceive_5, align=left] {Expected P3, got P5, discard, CumAck=2}; 

\onslide<12->
  \node [left=0.1 of pEndSend_3b, align=right] {Timeout for ACK 4!};
  \pplusa{15}{hpiyellow!80}{2}{0.25}{4b}{}
  \node [left=0.1 of pStartSend_4b, align=right] {Retransmit 4, send window stays at 0};

\onslide<13->
  \node [right=0.1 of pEndReceive_3b, align=left] {Expected P3, got P3b, deliver, send CumAck=3}; 

\onslide<14->
  \node [left=0.1 of pEndSend_4b, align=right] {Timeout for ACK 5!};
  \pplusa{17.5}{hpired!80}{2}{0.25}{5b}{}
  \node [left=0.1 of pStartSend_5b, align=right] {Retransmit 5, send window stays at 0};


\onslide<15->
  \node [left=0.1 of aEndReceive_3b, align=right] {Increase send window to 1};

\onslide<16->
  \node [right=0.1 of pEndReceive_4b, align=left] {Expected P4, got P4b, deliver, send CumAck=4}; 

\onslide<17->
  \pplusa{20}{green!20}{2}{0.25}{6}{}
  \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};


\onslide<18->

  \node [right=0.1 of pEndReceive_5b, align=left] {Expected P5, got P5b, deliver, send CumAck=5}; 


\end{tikzpicture}}
\caption{Go-Back-N example. Note: sequence numbers 3b, 4b, 5b only shown for better illustrations; real packet sequence numbers do \textbf{not} distinguish between original and retransmission.}
\label{fig:ll:gobbackn}
\end{figure}
**** Selective repeat: Example trace 

\begin{figure}[h]
  \centering
  \maxsizebox{!}{0.6\textheight}{
  \begin{tikzpicture}
  \label{page:ll:selective_repeat}
  \node [fill=hpiorange!10](a) {A};
  \node [fill=hpiblue!10, right=3cm of a] (b) {B};

  \draw (a) -- ++(0,-25); 
  \draw (b) -- ++(0,-25);


  \pplusa{0}{hpiorange!30}{2}{0.25}{1}{}
  \node [left=0.1 of pStartSend_1, align=right] {Send window=3, reduce to 2};
  \node [right=0.1 of pEndReceive_1, align=left] {Expected P1, got P1, deliver, CumAck=1}; 
\pause
  \pplusa{2.5}{hpiblue!30}{2}{0.25}{2}{}
  \node [left=0.1 of pStartSend_2, align=right] {Send window=2, reduce to 1};
  \node [right=0.1 of pEndReceive_2, align=left] {Expected P2, got P2, deliver, CumAck=2}; 
\pause
  \pplusa{5}{hpiyellow!30}{2}{0.25}{3}{X}
  \node [left=0.1 of pStartSend_3, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_1, align=right] {Increase send window to 1};
\pause
  \pplusa{7.5}{hpired!30}{2}{0.25}{4}{}
  \node [left=0.1 of pStartSend_4, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_2, align=right] {Increase send window to 1};  
\pause
  \pplusa{10}{hpiorange!80}{2}{0.25}{5}{}
  \node [left=0.1 of pStartSend_5, align=right] {Send window=1, reduce to 0};
\pause
  \node [right=0.1 of pEndReceive_4, align=left] {Expected P3, got P4, buffer P4, CumAck=2 + NACK=3, SelAck=4}; 
\pause
  \node [left=0.1 of pEndSend_5, align=right] {Timeout for ACK 3!};
  \pplusa{12.5}{hpiblue!80}{2}{0.25}{3b}{}
  \node [left=0.1 of pStartSend_3b, align=right] {Retransmit 3, send window stays at 0};
\pause
  \node [right=0.1 of pEndReceive_5, align=left] {Expected P3, got P5, buffer P5, CumAck=2 + NACK=3, SelAck=4,5}; 
\pause
  \node [left=0.1 of aEndReceive_4, align=right] {NACK 3 provides no new information, already retransmitted, SelAck 4 increases SendWindow to 1};
\pause
  \pplusa{15}{hpiyellow!80}{2}{0.25}{6}{}
  \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};
\pause
  \node [left=0.1 of aEndReceive_5, align=right] {NACK 3 provides no new information, already retransmitted, SelAck 5 increases SendWindow to 1};
\pause
  \node [right=0.1 of pEndReceive_3b, align=left] {Expected P3, got P3b, deliver 3, 4, 5, send CumAck=5}; 
\pause
  \pplusa{17.5}{hpired!80}{2}{0.25}{7}{}
\pause
  \node [right=0.1 of pEndReceive_6, align=left] {Expected P6, got P6, deliver 6, send CumAck=6}; 

%----------------------------------
%   \pplusa{20}{green!20}{2}{0.25}{8}{}

%   Sender comments:
  
  
  % \node [left=0.1 of pStartSend_4b, align=right] {Retransmit 4, send window stays at 0};
  % \node [left=0.1 of pStartSend_5b, align=right] {Retransmit 5, send window stays at 0};

  % \node [left=0.1 of aEndReceive_3b, align=right] {Increase send window to 1};
  
  % \node [left=0.1 of pStartSend_6, align=right] {Send window=1, reduce to 0};

  % Receiver comments: 

  



  
  % \node [right=0.1 of pEndReceive_4b, align=left] {Expected P4, got P4b, deliver, send CumAck=4}; 

  % \node [right=0.1 of pEndReceive_5b, align=left] {Expected P5, got P5b, deliver, send CumAck=5}; 
  
\end{tikzpicture}
}
\caption{Selective repeat example. Note: sequence numbers 3b, 4b, 5b only shown for better illustrations; real packet sequence numbers do \textbf{not} distinguish between original and retransmission.}
\label{fig:ll:selective_repeat}
\end{figure}
