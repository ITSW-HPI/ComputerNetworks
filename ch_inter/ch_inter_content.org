\label{ch:inter}

\begin{frame}[title={bg=Hauptgebaeude_Tag}]
 \maketitle 
\end{frame}



**** The story so far  
- So far: we can communicate between nodes all connected directly to the same medium

**** Plans for this chapter 

- How to grow beyond a single medium? 
- What options exist to interconnect local networks into larger configurations?
- Repeaters, hubs, bridges, switches, routers, gateways
- What are their limitations?
- How does it relate to the networking layer in the ISO/OSI stack? 


\vskip-2.5em

*****                     
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:


****** Learning outcomes 

*****                    
      :PROPERTIES:
      :BEAMER_env: block
      :BEAMER_col: 0.48
      :END:   



*****                               :B_ignoreheading:
      :PROPERTIES:
      :BEAMER_env: ignoreheading
      :END:



** LAN interconnection

**** The problem
- Let’s start from classic Ethernet
- Single wire, single collision domain
- Works fine for a limited number of stations
- Collapses when number of nodes becomes too large
- CSMA/CD will not keep up, limited bandwidth
-  $\leadsto$ Multiple LANs are necessary
- Not an inherent Ethernet problem
- Will happen on any medium, with any protocol
**** Several reasons for multiple LANs
- Limited number of users/throughput in a single LAN
- Historical reasons
- Different groups started out individually setting up networks
- Usually heterogeneous
- Geographic distribution of different groups over different buildings, campus, …
- Impractical/impossible to use a single LAN because of distance
- Long round-trip delay will negatively influence performance
- Reliability
- Don’t put all your eggs into one basket
- E.g., ``babbling idiot'' problem
- Security
- Promiscuous operation – contain possible damage
**** Several options to overcome some of these limitations
- Can be classified according to the layer in which they work


** Physical-layer interconnects

**** Repeaters
- Simplest option: Repeater
- Physical layer device
- Connected to two cables
- Amplifies signal arriving on either one, puts on the other cable
- Essentially an analog amplifier to extend physical reach of a cable
- Combats attenuation
- Neither understands nor cares about content (bits) of packets
**** Hub
- Similar to repeaters: Hubs
- Connects multiple cables electrically, not just two
- Usually, does not amplify the signal
- Also physical layer device
- Also does not understand or process content of packets
- All connected cables form a single collision domain
**** Physical layer solutions not satisfactory
- Physical layer devices – repeater, hub – do not solve the more interesting problems
- E.g., how to handle load
- Some knowledge of the data link layer structure is necessary
- To be able to inspect the content of the packets/frames and do something with that knowledge
-  $\leadsto$ Link-layer solutions
- Bridge & switch
- Historic distinction 
- Switch: Interconnect several terminals
- Bridge: Interconnect several networks
- But terms nowadays often used interchangeably 

** Data-link-layer interconnects

**** Switch
- Use a switch to connect several terminals
- Without forming a single collision domain
- Switch inspects an arriving packet’s destination addresses and forwards its only on the right cable
- Does not bother the other terminals
- Needs: buffer, knowledge where which terminal is connected
- How to obtain knowledge about directions?
- Simple: observe from where packets come to decide how to reach the sending terminal
- Backward learning
**** Backward learning, forwarding table  
- Packet with following parameters arrives at a switch: 
- Source address X 
- Destination address Y
- Arrives at port P 
- Switch concludes: X can be reached by sending to port P 
- Enters this is its forwarding table
- Assumption: Symmetric network! 
- Nothing concluded about Y! 
- Forwarding table:  
**** Bridges
- Switches are limited in that they connect simple terminals
- Sometimes, entire networks have to be connected: Bridges
- Bridge also inspects incoming packet and forwards only towards destination
- How to learn here where destination is? Does simple ``backward'' learning suffice? 
- Each network connected to a bridge is a separate collision domain
- Bridges can also interconnect different LAN types
- Not possible on physical layer only
**** Switches & bridges
- Typical combination: Bridge as ``just another terminal'' for a switch
**** Backward learning in bridges
- Backward learning is trivial in a switch – how about a bridge?
- Example: A sends packet to E
- Suppose bridges B1 and B2 know where E is
- B2 will see A’s packet coming from LAN2
- Since B2 does not know about LAN1, B2 will assume A to be on LAN2
- Which is fine! B1 will forward any packet destined to A arriving at LAN2 to LAN1, so that works out nicely
**** Backward learning in bridges – bootstrapping 
- In previous example: how does bridge B2 know initially where node E is?
- Answer: It does NOT know
- Option 1: Manual configuration – not nice!
- Option 2: Do not care – simply forward the data everywhere for an unknown address
- Except to the network where it came from 
- Algorithm is thus: flood if not known, discard if known to be not necessary, forward specifically if destination is known
**** Flooding by bridges – problems 
- Previous ``backward learning by flooding'' is simple, but problematic
- Consider example topology:
- Second bridge for reliability
**** Solution 1: Somehow restrict flooding
- Unrestricted, brute-force flooding evidently fails
- Avoid packet looping indefinitely by remembering which packets have already been forwarded 
- If already seen and forwarded a packet, simply drop it
- Requires: State & uniqueness
- Bridges have to remember which packets have passed through 
- Packets must be uniquely identifiable – at least source, destination, and sequence number are necessary to distinguish packets 
-  $\leadsto$ Big overhead! 
- Especially state is a problem, as is time to search this amount of state 
- Usually not used 
**** Solution 2: Spanning trees
- Packet loops are caused by cycles in the graph defined by the bridges
- Think of bridges as edges, LANs as nodes in this graph
- Redundant bridges form loops in this graph
- Idea: Turn this into a loop-free, acyclic graph
- Simplest approach: Compute a spanning tree on this LAN-bridge graph
- Simple, self-configured, no manual intervention
- But not optimal: actual capacity of installed bridges might not be fully exploited
- Buzzword: IEEE 802.1dIEEE 802.1w
- 
**** Spanning tree of bridges 
**** Spanning trees: Bridges as edges in graph 
**** Rapid Spanning Tree Protocol (RSTP)
**** Convergence: Switch and bridge
- Traditionally, distinction between switch and bridge made sense
- Today: most devices contain both types of functionality
- Terms be treated more or less interchangeably today 
- Often more a marketing distinction than a technical one
- 
**** Addresses in packet? 
- Suppose we send a packet from A to H
- Which addresses (source, destination) are in the packet when it 
- Arrives or leaves at B1, B2?
- Why is that the case? Because we are in a single LAN  


** Higher-layer interconnects

**** Routers
- All devices so far either ignored addresses (repeaters, hubs) or worked on MAC-layer addresses (switches, bridges)
- For interconnection outside a single LAN/connection of LAN, these simple addresses are insufficient
- Main issue: ``flat'', unstructured addresses do not scale 
- In spanning tree, there is an entry for every device’s designated output port!
-  $\leadsto$ Need more sophisticated addressing structure and devices that operate on it
-  $\leadsto$ Routers and routing!
- Treated in the next chapter
**** Gateways
- If even routers will not do, higher-layer interconnection is necessary: Gateways
- Work at transport level and upwards
- E.g., application gateways transforming between HTML $ WML or HTTP $ WAP
- E.g., transcoding gateways for media content

** VLAN operation 
- Switch knows: 
- Which VLANs exist on which ports 
- VLAN of incoming packet, determined by: 
- Fixed port $\leadsto$  VLAN mapping 
- MAC address! VLAN mapping
- IP address $\leadsto$ VLAN mapping
- But: layer violation!!! 
- Alternative: IEEE 802.1Q ``tagged'' VLANs
- Make VLAN explicit! 
- Forwarding: 
  - Broadcasts: only on ports which carry the packet’s VLAN 
  - Unicast: Use VLAN-specific forwarding table 
- Effectively, one forwarding table per VLAN 

**** Further topic in LAN/LAN interconnection: VLAN
- Problem: LANs/switches are geared towards physical proximity of devices
- But: LANs should respect logical proximity
- Connect devices of working groups together, irrespective where they happen to be located
- Idea: put a virtual LAN on top of an existing physical LAN
- Switches (or bridges) need configuration tables which port belongs to which VLAN
- Only forward packets to ports of correct VLAN
**** IEEE 802.1q packet format 
**** IEEE 802.11q – discussion 
- It changed the Ethernet header!!! 
- Big legacy issue at the time (ca. 1995)
- Compatibility with existing cards? Who generates header? Maximum frame size exceeded when inserting new field? …? 
- Observation: End machines do not really use the VLAN fields, only switches/bridges 
- VLAN tags not needed on end hosts – switch links 
- Can be inserted by first switch, removed by last one, if necessary
- And here, use one of the three options from previous slide 

** Conclusion 
**** Conclusion
- Single LANs are insufficient to provide communication for all but the simplest installations
- Interconnection of LANs necessary
- Interconnect on purely physical layer: Repeater, hub
- Interconnect on data link layer: Bridges, switches
- Interconnect on network layer: Router
- Interconnect on higher layer: Gateway
- Problems
- E.g., redundant bridges can cause traffic floods; need spanning tree algorithm
- Simple addresses do not scale; need routers

